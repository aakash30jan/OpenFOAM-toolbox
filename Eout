%includefile "/usr/local/share/swig/4.0.0/swig.swg" %beginfile
/* -----------------------------------------------------------------------------
 * swig.swg
 *
 * Common macro definitions for various SWIG directives.  This file is always 
 * included at the top of each input file.
 * ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
 * User Directives 
 * ----------------------------------------------------------------------------- */

/* Deprecated SWIG-1.1 directives */













/* Code insertion directives such as %wrapper %{ ... %} */







/* Class extension */



/* %ignore directive */




/* Access control directives */









/* Generation of default constructors/destructors (old form, don't use) */





/* Disable the generation of implicit default constructor */




/* Disable the generation of implicit default destructor (dangerous) */




/* Enable the generation of copy constructor */




/* Force the old nodefault behavior, ie disable both constructor and destructor */




/* the %exception directive */








/* the %allowexception directive allows the %exception feature to
   be applied to set/get variable methods */




/* the %exceptionvar directive, as %exception but it is only applied
   to set/get variable methods. You don't need to use the
   %allowexception directive when using %exceptionvar.
*/








/* the %catches directive */



/* the %exceptionclass directive */




/* the %newobject directive */




/* the %delobject directive */




/* the %refobject/%unrefobject directives */








/* Directives for callback functions (experimental) */




/* the %nestedworkaround directive (deprecated) */




/* the %flatnested directive */




/* the %fastdispatch directive */




/* directors directives */




/* naturalvar directives */




/* nspace directives */




/* valuewrapper directives */





/* Contract support - Experimental and undocumented */




/* Macro for setting a dynamic cast function */






/* aggregation support */
/*
  This macro performs constant aggregation.  Basically the idea of
  constant aggregation is that you can group a collection of constants
  together.  For example, suppose you have some code like this:

       #define UP  1
       #define DOWN 2
       #define LEFT 3
       #define RIGHT 4

  Now, suppose you had a function like this:

       int move(int direction)

  In this case, you might want to restrict the direction argument to
  one of the supplied constant names. To do this, you could write some
  typemap code by hand.  Alternatively, you can use the
  %aggregate_check macro defined here to create a simple check
  function for you.  Here is an example:

    %aggregate_check(int, check_direction, UP, DOWN, LEFT, RIGHT);

  Now, using a typemap

    %typemap(check) int direction {
      if (!check_direction($1)) SWIG_exception(SWIG_ValueError,"Bad direction.");
    }

  or a contract (better)

    %contract move(int x) {
    require:
        check_direction(x);
    }

*/
   















/* -----------------------------------------------------------------------------
 * %rename predicates
 * ----------------------------------------------------------------------------- */
/* 
   Predicates to be used with %rename, for example:

   - to rename all the functions:

     %rename("%(utitle)s", %$isfunction) "";

   - to rename only the member methods:

     %rename("m_%(utitle)s", %$isfunction, %$ismember) "";

   - to rename only the global functions:

      %rename("m_%(utitle)s", %$isfunction, %$not %$ismember) "";

     or

      %rename("g_%(utitle)s", %$isfunction, %$isglobal) "";

   - to ignore the enumitems in a given class:

     %rename("$ignore", %$isenumitem, %$classname="MyClass") "";

   we use the prefix '%$' to avoid clashes with other swig
   macros/directives.

*/

 









  /* %constant definition */






























/* -----------------------------------------------------------------------------
 * Include all the warnings labels and macros 
 * ----------------------------------------------------------------------------- */

%includefile "/usr/local/share/swig/4.0.0/swigwarnings.swg" %beginfile
/*
  Include the internal swig macro codes. These macros correspond to
  the one found in Source/Include/swigwarn.h plus the 'SWIG' prefix.
  
  For example, in the include file 'swigwarn.h' you will find

    #define WARN_TYPEMAP_CHARLEAK ...

  and in the 'swigwarn.swg' interface, you will see

    %define SWIGWARN_TYPEMAP_CHARLEAK ...

  This code can be used in warning filters as follows:

    %warnfilter(SWIGWARN_TYPEMAP_CHARLEAK);

  Warnings messages used in typemaps. Message names will be the same
  as those in Lib/swigwarn.swg but with the suffix _MSG.
   
  For example, for the code SWIGWARN_TYPEMAP_CHARLEAK, once you use

    %typemapmsg(CHARLEAK,<msg>);

  you use the message in your typemap as

    %typemap(varin,warning=SWIGWARN_TYPEMAP_CHARLEAK_MSG) char * 

  while you suppress the warning using

    %warnfilter(SWIGWARN_TYPEMAP_CHARLEAK);

  as described above.
*/

/* -----------------------------------------------------------------------------
 * SWIG warning codes
 * ----------------------------------------------------------------------------- */

%includefile "/usr/local/share/swig/4.0.0/swigwarn.swg" %beginfile
/* SWIG warning codes */




/* -- Deprecated features -- */




























/* -- Preprocessor -- */








/* -- C/C++ Parser -- */





























  /* redundant now */
  /* redundant now */


	/* new */
	/* delete */
	/* + */
	/* - */
	/* * */
	/* / */
	/* % */
	/* ^ */
	/* & */
	/* | */
	/* ~ */
	/* ! */
	/* = */
	/* < */
	/* > */
	/* += */
	/* -= */
	/* *= */
	/* /= */
	/* %= */
	/* ^= */
	/* &= */
	/* |= */
	/* << */
	/* >> */
	/* <<= */
	/* >>= */
	/* == */
	/* != */
	/* <= */
	/* >= */
	/* && */
	/* || */
	/* ++ */
	/* -- */
	/* , */
	/* ->* */
	/* -> */
	/* () */
	/* [] */
	/* + */
	/* - */
	/* * */
	/* & */
	/* new [] */
	/* delete [] */
	/* operator *() */

/* 394-399 are reserved */

/* -- Type system and typemaps -- */






















	/* mostly used in directorout typemaps */








/* -- Fragments -- */


/* -- General code generation -- */

























/* -- Reserved (600-799) -- */

/* -- Language module specific warnings (700 - 899) -- */

















/* please leave 700-719 free for D */



/* please leave 720-739 free for Scilab */



/* please leave 740-759 free for Python */




/* please leave 800-809 free for Ruby */



















/* please leave 810-829 free for Java */



















/* please leave 830-849 free for C# */













/* please leave 850-869 free for Modula 3 */





/* please leave 870-889 free for PHP */



/* please leave 890-899 free for Go */

/* -- User defined warnings (900 - 999) -- */

%endoffile

/* -----------------------------------------------------------------------------
 * Auxiliary macros
 * ----------------------------------------------------------------------------- */

/* Macro to define warning messages */



/* -----------------------------------------------------------------------------
 *  Typemap related warning messages
 * ----------------------------------------------------------------------------- */







/* -----------------------------------------------------------------------------
 * Operator related warning messages 
 * ----------------------------------------------------------------------------- */



















































/* -----------------------------------------------------------------------------
 * Macros for keyword and built-in names 
 * ----------------------------------------------------------------------------- */





/* -----------------------------------------------------------------------------
 * Warning filter feature
 * ----------------------------------------------------------------------------- */






%endoffile

/* -----------------------------------------------------------------------------
 * Overloading support
 * ----------------------------------------------------------------------------- */

/*
 * Function/method overloading support.   This is done through typemaps,
 * but also involves a precedence level.
 */

/* Macro for overload resolution */



/* Macros for precedence levels */





































































/* -----------------------------------------------------------------------------
 * Default handling of certain overloaded operators 
 * ----------------------------------------------------------------------------- */


%rename("$ignore:"        "350:operator new ignored"  )     operator new;
%rename("$ignore:"     "351:operator delete ignored"  )  operator delete;
%rename("$ignore:"     "394:operator new[] ignored"  )  operator new[];
%rename("$ignore:"     "395:operator delete[] ignored"  )  operator delete[];

/* add C++ operator aliases */
%rename("operator &&") operator and;    // `and'    `&&'
%rename("operator ||") operator or;     // `or'     `||'
%rename("operator !")  operator not;    // `not'     `!'
%rename("operator &=") operator and_eq; // `and_eq'  `&='
%rename("operator &")  operator bitand; // `bitand'  `&'
%rename("operator |")  operator bitor;  // `bitor'   `|'
%rename("operator ~")  operator compl;  // `compl'   `~'
%rename("operator !=") operator not_eq; // `not_eq'  `!='
%rename("operator |=") operator or_eq;  // `or_eq'   `|='
%rename("operator ^")  operator xor;    // `xor'     `^'
%rename("operator ^=") operator xor_eq; // `xor_eq'  `^='

/* Smart pointer handling */

%rename(__deref__) *::operator->;
%rename(__ref__)   *::operator*();
%rename(__ref__)   *::operator*() const;

/* Define std namespace */
namespace std {
  /* Warn about std::initializer_list usage. The constructor/method where used should probably be ignored. See docs. */
  template<typename T> class initializer_list {};
  %typemap(in, warning="476:Initialization using std::initializer_list." ) initializer_list<T> ""
  %typemap(typecheck, precedence=      0     ) initializer_list<T> ""
}


/* -----------------------------------------------------------------------------
 * Default char * and C array typemaps
 * ----------------------------------------------------------------------------- */

/* Set up the typemap for handling new return strings */


%typemap(newfree) char * "delete [] $1;";




/* Default typemap for handling char * members */


%typemap(memberin) char * {
  delete [] $1;
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(memberin,warning=        "451:Setting a const char * variable may leak memory." ) const char * {
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(globalin) char * {
  delete [] $1;
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(globalin,warning=        "451:Setting a const char * variable may leak memory." ) const char * {
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}






































/* Character array handling */

%typemap(memberin) char [ANY] {
  if($input) {
    strncpy((char*)$1, (const char *)$input, $1_dim0-1);
    $1[$1_dim0-1] = 0;
  } else {
    $1[0] = 0;
  }
}

%typemap(globalin) char [ANY] {
  if($input) {
    strncpy((char*)$1, (const char *)$input, $1_dim0-1);
    $1[$1_dim0-1] = 0;
  } else {
    $1[0] = 0;
  }
}

%typemap(memberin) char [] {
  if ($input) strcpy((char *)$1, (const char *)$input);
  else $1[0] = 0;
}

%typemap(globalin) char [] {
  if ($input) strcpy((char *)$1, (const char *)$input);
  else $1[0] = 0;
}

/* memberin/globalin typemap for arrays. */

%typemap(memberin) SWIGTYPE [ANY] {
  size_t ii;
  $1_basetype *b = ($1_basetype *) $1;
  for (ii = 0; ii < (size_t)$1_size; ii++) b[ii] = *(($1_basetype *) $input + ii);
}

%typemap(globalin) SWIGTYPE [ANY] {
  size_t ii;
  $1_basetype *b = ($1_basetype *) $1;
  for (ii = 0; ii < (size_t)$1_size; ii++) b[ii] = *(($1_basetype *) $input + ii);
}

/* memberin/globalin typemap for double arrays. */

%typemap(memberin) SWIGTYPE [ANY][ANY] {
  $basetype (*inp)[$1_dim1] = ($basetype (*)[$1_dim1])($input);
  $basetype (*dest)[$1_dim1] = ($basetype (*)[$1_dim1])($1);
  size_t ii = 0;
  for (; ii < $1_dim0; ++ii) {
    $basetype *ip = inp[ii];
    $basetype *dp = dest[ii];
    size_t jj = 0;
    for (; jj < $1_dim1; ++jj) dp[jj] = ip[jj];
  }
}

%typemap(globalin) SWIGTYPE [ANY][ANY] {
  $basetype (*inp)[$1_dim1] = ($basetype (*)[$1_dim1])($input);
  $basetype (*dest)[$1_dim1] = ($basetype (*)[$1_dim1])($1);
  size_t ii = 0;
  for (; ii < $1_dim0; ++ii) {
    $basetype *ip = inp[ii];
    $basetype *dp = dest[ii];
    size_t jj = 0;
    for (; jj < $1_dim1; ++jj) dp[jj] = ip[jj];
  }
}

/* -----------------------------------------------------------------------------
 *  Runtime code
 * ----------------------------------------------------------------------------- */

/*  The SwigValueWrapper class  */

/*  
 * This template wrapper is used to handle C++ objects that are passed or 
 * returned by value.   This is necessary to handle objects that define
 * no default-constructor (making it difficult for SWIG to properly declare
 * local variables).
 *
 * The wrapper is used as follows.  First consider a function like this:
 *
 *      Vector cross_product(Vector a, Vector b)
 *
 * Now, if Vector is defined as a C++ class with no default constructor, 
 * code is generated as follows:
 *
 *     Vector *wrap_cross_product(Vector *inarg1, Vector *inarg2) {
 *          SwigValueWrapper<Vector>  arg1;
 *          SwigValueWrapper<Vector>  arg2;
 *          SwigValueWrapper<Vector> result;
 *
 *          arg1 = *inarg1;
 *          arg2 = *inarg2;
 *          ...            
 *          result = cross_product(arg1,arg2);
 *          ...
 *          return new Vector(result);
 *    }
 *         
 * In the wrappers, the template SwigValueWrapper simply provides a thin
 * layer around a Vector *.  However, it does this in a way that allows
 * the object to be bound after the variable declaration (which is not possible
 * with the bare object when it lacks a default constructor).  
 *
 * An observant reader will notice that the code after the variable declarations
 * is *identical* to the code used for classes that do define default constructors.
 * Thus, this neat trick allows us to fix this special case without having to
 * make massive changes to typemaps and other parts of the SWIG code generator.
 *
 * Note: this code is not included when SWIG runs in C-mode, when classes
 * define default constructors, or when pointers and references are used.
 * SWIG tries to avoid doing this except in very special circumstances.
 *
 * Note: This solution suffers from making a large number of copies
 * of the underlying object.  However, this is needed in the interest of
 * safety and in order to cover all of the possible ways in which a value
 * might be assigned.  For example:
 *
 *       arg1 = *inarg1;       // Assignment from a pointer
 *       arg1 = Vector(1,2,3); // Assignment from a value  
 *
 * The class offers a strong guarantee of exception safety.
 * With regards to the implementation, the private SwigMovePointer nested class is 
 * a simple smart pointer with move semantics, much like std::auto_ptr.
 *
 * This wrapping technique was suggested by William Fulton and is henceforth
 * known as the "Fulton Transform" :-).
 */


%insert("runtime") %{
#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};%}

/*
 * SwigValueInit() is a generic initialisation solution as the following approach:
 * 
 *       T c_result = T();
 * 
 * doesn't compile for all types for example:
 * 
 *       unsigned int c_result = unsigned int();
 */
%insert("runtime") %{
template <typename T> T SwigValueInit() {
  return T();
}
#endif
%}


/*  The swiglabels  */

%insert("runtime") "swiglabels.swg"


%endoffile

%includefile "/usr/local/share/swig/4.0.0/scilab/scilab.swg" %beginfile
%includefile "/usr/local/share/swig/4.0.0/typemaps/swigmacros.swg" %beginfile
/* -----------------------------------------------------------------------------
 * SWIG API. Portion only visible from SWIG
 * ----------------------------------------------------------------------------- */
/*
  This file implements the internal macros of the 'SWIG API', which
  are useful to implement all the SWIG target languages.

  Basic preprocessor macros:
  --------------------------

    %arg(Arg)               Safe argument wrap
    %str(Arg)               Stringify the argument
    %begin_block            Begin an execution block
    %end_block              End an execution block
    %block(Block)           Execute Block as an execution block
    %define_as(Def, Val)    Define 'Def' as 'Val', expanding Def and Val first
    %ifcplusplus(V1, V2)    if C++ Mode; then V1; else V2; fi


  Casting Operations:
  -------------------

  SWIG provides the following casting macros, which implement the
  corresponding C++ casting operations:

    %const_cast(a, Type)         const_cast<Type >(a)
    %static_cast(a, Type)      	 static_cast<Type >(a)
    %reinterpret_cast(a, Type) 	 reinterpret_cast<Type >(a)
    %numeric_cast(a, Type)     	 static_cast<Type >(a)
    %as_voidptr(a)            	 const_cast<void *>(static_cast<const void *>(a))
    %as_voidptrptr(a)        	 reinterpret_cast<void **>(a)

  or their C unsafe versions. In C++ we use the safe version unless
  SWIG_NO_CPLUSPLUS_CAST is defined (usually via the -nocppcast swig flag).


  Memory allocation:
  ------------------

  These allocation/freeing macros are safe to use in C or C++ and
  dispatch the proper new/delete/delete[] or free/malloc calls as
  needed.

    %new_instance(Type)             Allocate a new instance of given Type
    %new_copy(value,Type)           Allocate and initialize a new instance with 'value'
    %new_array(size,Type)           Allocate a new array with given size and Type and zero initialize
    %new_copy_array(cptr,size,Type) Allocate and initialize a new array from 'cptr'
    %delete(cptr)                   Delete an instance
    %delete_array(cptr)             Delete an array


  Auxiliary loop macros:
  ----------------------

    %formacro(Macro, Args...) or %formacro_1(Macro, Args...)
       for i in Args
       do
          Macro($i)
       done

    %formacro_2(Macro2, Args...)
       for i,j in Args
       do
          Macro2($i, $j)
       done


  Flags and conditional macros:
  -----------------------------

     %mark_flag(flag)
       flag := True

     %evalif(flag,expr)
       if flag; then
         expr
       fi

     %evalif_2(flag1 flag2,expr)
       if flag1 and flag2; then
         expr
       fi


*/
/* -----------------------------------------------------------------------------
 * Basic preprocessor macros
 * ----------------------------------------------------------------------------- */











/* define a new macro */


/* include C++ or else value */








/* insert the SWIGVERSION in the interface and the wrapper code */

%insert("header") {
#define SWIGVERSION 0x040000 
#define SWIG_VERSION SWIGVERSION
}




/* -----------------------------------------------------------------------------
 * Casting operators
 * ----------------------------------------------------------------------------- */
























%insert("header") {
#define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 
}


/* -----------------------------------------------------------------------------
 * Allocating/freeing elements
 * ----------------------------------------------------------------------------- */

















/* -----------------------------------------------------------------------------
 * SWIG names and mangling
 * ----------------------------------------------------------------------------- */








/* -----------------------------------------------------------------------------
 * Auxiliary loop macros
 * ----------------------------------------------------------------------------- */


/* for loop for macro with one argument */






/* for loop for macro with one argument */



/* for loop for macro with two arguments */






/* for loop for macro with two arguments */


/* -----------------------------------------------------------------------------
 * SWIG flags
 * ----------------------------------------------------------------------------- */

/*
  mark a flag, ie, define a macro name but ignore it in
  the interface.

  the flag can be later used with %evalif
*/




/*
  %evalif and %evalif_2 are use to evaluate or process
  an expression if the given predicate is 'true' (1).
*/
















%endoffile
%includefile "/usr/local/share/swig/4.0.0/typemaps/fragments.swg" %beginfile
/*
  Fragments
  =========
  See the "Typemap fragments" section in the documentation for understanding
  fragments. Below is some info on how fragments and automatic type
  specialization is used.

  Macros that make the automatic generation of typemaps easier are provided.

  Consider the following code:

      %fragment(SWIG_From_frag(bool), "header") {     
      static PyObject*		      
      SWIG_From_dec(bool)(bool value)	       
      {					       
        PyObject *obj = value ? Py_True : Py_False;  
        Py_INCREF(obj);			       
        return obj;				       
      }					       
      }					       
      					 
      %typemap(out, fragment=SWIG_From_frag(bool)) bool {
        $result = SWIG_From(bool)($1));
      }

  Here the macros

      SWIG_From_frag  => fragment 
      SWIG_From_dec   => declaration 
      SWIG_From       => call 
      
  allow you to define/include a fragment, and declare and call the
  'from-bool' method as needed. In the simpler case, these macros 
  just return something like

      SWIG_From_frag(bool)  => "SWIG_From_bool"
      SWIG_From_dec(bool)   =>  SWIG_From_bool
      SWIG_From(bool)       =>  SWIG_From_bool

  But they are specialized for the different languages requirements,
  such as perl or tcl that requires passing the interpreter pointer,
  and also they can manage C++ ugly types, for example:
  
      SWIG_From_frag(std::complex<double>)  => "SWIG_From_std_complex_Sl_double_Sg_"
      SWIG_From_dec(std::complex<double>)   =>  SWIG_From_std_complex_Sl_double_Sg_
      SWIG_From(std::complex<double>)       =>  SWIG_From_std_complex_Sl_double_Sg_


  Hence, to declare methods to use with typemaps, always use the
  SWIG_From* macros. In the same way, the SWIG_AsVal* and SWIG_AsPtr*
  set of macros are provided.
    
*/


/* -----------------------------------------------------------------------------
 * Define the basic macros to 'normalize' the type fragments
 * ----------------------------------------------------------------------------- */




































/* ------------------------------------------------------------
 * common fragments 
 * ------------------------------------------------------------ */

/* Default compiler options for gcc allow long_long but not LLONG_MAX. 
 * Define SWIG_NO_LLONG_MAX if this added limits support is not wanted. */
%fragment("<limits.h>","header") %{
#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif
%}

%fragment("<math.h>","header") %{
#include <math.h>
%}

%fragment("<wchar.h>","header") %{
#include <wchar.h>
#include <limits.h>
#ifndef WCHAR_MIN
#  define WCHAR_MIN 0
#endif
#ifndef WCHAR_MAX
#  define WCHAR_MAX 65535
#endif
%}

%fragment("<float.h>","header") %{
#include <float.h>
%}

%fragment("<stdio.h>","header") %{
#include <stdio.h>
#if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
# ifndef snprintf
#  define snprintf _snprintf
# endif
#endif
%}

%fragment("<stdlib.h>","header") %{
#include <stdlib.h>
#ifdef _MSC_VER
# ifndef strtoull
#  define strtoull _strtoui64
# endif
# ifndef strtoll
#  define strtoll _strtoi64
# endif
#endif
%}

%fragment("<stddef.h>", "header") %{
#include <stddef.h>
%}

%fragment("<string>", "header") %{
#include <string>
%}

%fragment("<stdexcept>", "header") %{
#include <stdexcept>
%}

%fragment("<algorithm>", "header") %{
#include <algorithm>
%}

%fragment("SWIG_isfinite","header",fragment="<math.h>,<float.h>") %{
/* Getting isfinite working pre C99 across multiple platforms is non-trivial. Users can provide SWIG_isfinite on older platforms. */
#ifndef SWIG_isfinite
/* isfinite() is a macro for C99 */
# if defined(isfinite)
#  define SWIG_isfinite(X) (isfinite(X))
# elif defined __cplusplus && __cplusplus >= 201103L
/* Use a template so that this works whether isfinite() is std::isfinite() or
 * in the global namespace.  The reality seems to vary between compiler
 * versions.
 *
 * Make sure namespace std exists to avoid compiler warnings.
 *
 * extern "C++" is required as this fragment can end up inside an extern "C" { } block
 */
namespace std { }
extern "C++" template<typename T>
inline int SWIG_isfinite_func(T x) {
  using namespace std;
  return isfinite(x);
}
#  define SWIG_isfinite(X) (SWIG_isfinite_func(X))
# elif defined(_MSC_VER)
#  define SWIG_isfinite(X) (_finite(X))
# elif defined(__sun) && defined(__SVR4)
#  include <ieeefp.h>
#  define SWIG_isfinite(X) (finite(X))
# endif
#endif
%}

%fragment("SWIG_Float_Overflow_Check","header",fragment="<float.h>,SWIG_isfinite") %{
/* Accept infinite as a valid float value unless we are unable to check if a value is finite */
#ifdef SWIG_isfinite
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX) && SWIG_isfinite(X))
#else
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX))
#endif
%}

/* -----------------------------------------------------------------------------
 * special macros for fragments
 * ----------------------------------------------------------------------------- */

/* Macros to derive numeric types */








































/* Macro for 'signed long' derived types */






/* Macro for 'unsigned long' derived types */







/* Macro for floating point derived types (original macro) */






/* Macro for floating point derived types */







/* Macros for missing fragments */















%endoffile
%includefile "/usr/local/share/swig/4.0.0/scilab/scimacros.swg" %beginfile
 

// Create Scilab variable


%endoffile
%includefile "/usr/local/share/swig/4.0.0/scilab/sciruntime.swg" %beginfile
%insert(runtime) "swigrun.swg";
%insert(runtime) "swigerrors.swg";

%insert(runtime) "scirun.swg";

%insert(init) %{
/* Module management functions */

#define SWIG_GetModule(clientdata) SWIG_Scilab_GetModule()
#define SWIG_SetModule(clientdata, pointer) SWIG_Scilab_SetModule(pointer)

SWIGRUNTIME swig_module_info*
SWIG_Scilab_GetModule(void) {
  return NULL;
}

SWIGRUNTIME void
SWIG_Scilab_SetModule(swig_module_info *swig_module) {
}
%}

%insert(init) "swiginit.swg"

%insert(init) %{
SWIGRUNTIME swig_type_info *
SWIG_Scilab_TypeQuery(const char *name) {
  if (SWIG_Module_Initialized()) {
    return SWIG_TypeQuery(name);
  }
  else {
    SWIG_Error(SWIG_RuntimeError, "the module is not initialized");
    return NULL;
  }
}
%}

%insert(init) %{
#ifdef __cplusplus
extern "C"
#endif
int <module>_Init(SWIG_GatewayParameters) {
  SWIG_InitializeModule(NULL);
  SWIG_CreateScilabVariables(pvApiCtx);
  swig_module_initialized = 1;
%}
%endoffile
%includefile "/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg" %beginfile
// Scilab fragments for primitive types
%includefile "/usr/local/share/swig/4.0.0/scilab/sciprimtypes.swg" %beginfile
%includefile "/usr/local/share/swig/4.0.0/scilab/scidouble.swg" %beginfile
/*
 * DOUBLE SCALAR
 */
%fragment("SWIG_" "AsVal" "_" {double}, "header", fragment="SWIG_SciDouble_AsDouble") {
#define SWIG_AsVal_double(scilabValue, valuePointer) SWIG_SciDouble_AsDouble(pvApiCtx, scilabValue, valuePointer, SWIG_Scilab_GetFuncName())
}
%fragment("SWIG_SciDouble_AsDouble", "header") {
SWIGINTERN int
SWIG_SciDouble_AsDouble(void *pvApiCtx, SwigSciObject iVar, double *pdblValue, char *fname) {
  SciErr sciErr;
  int iRet = 0;
  int *piAddrVar = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (!isDoubleType(pvApiCtx, piAddrVar) || isVarComplex(pvApiCtx, piAddrVar)) {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A real expected.\n"), fname, iVar);
    return SWIG_ERROR;
  }

  if (!isScalar(pvApiCtx, piAddrVar)) {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong size for input argument #%d: A real expected.\n"), fname, iVar);
    return SWIG_ERROR;
  }

  iRet = getScalarDouble(pvApiCtx, piAddrVar, pdblValue);
  if (iRet) {
    return SWIG_ERROR;
  }

  return SWIG_OK;
}
}

%fragment("SWIG_" "From" "_" {double}, "header", fragment="SWIG_SciDouble_FromDouble") { 
#define SWIG_From_double(scilabValue) SWIG_SciDouble_FromDouble(pvApiCtx, SWIG_Scilab_GetOutputPosition(), scilabValue, SWIG_Scilab_GetFuncName())
}
%fragment("SWIG_SciDouble_FromDouble", "header") {
SWIGINTERN int
SWIG_SciDouble_FromDouble(void *pvApiCtx, int iVarOut, double dblValue, char *fname) {
  if (createScalarDouble(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut, dblValue))
    return SWIG_ERROR;
  return SWIG_OK;
}
}

/*
 * DOUBLE ARRAY
 */

%fragment("SWIG_SciDouble_AsDoubleArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDouble_AsDoubleArrayAndSize(void *pvApiCtx, int iVar, int *iRows, int *iCols, double **pdValue, char *fname) {
  SciErr sciErr;
  int *piAddrVar = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (isDoubleType(pvApiCtx, piAddrVar) && !isVarComplex(pvApiCtx, piAddrVar)) {
    sciErr = getMatrixOfDouble(pvApiCtx, piAddrVar, iRows, iCols, pdValue);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
  }
  else {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A real matrix expected.\n"), fname, iVar);
    return SWIG_ERROR;
  }

  return SWIG_OK;
}
}

%fragment("SWIG_SciDouble_FromDoubleArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDouble_FromDoubleArrayAndSize(void *pvApiCtx, int iVarOut, int iRows, int iCols, double *pdblValue) {
  SciErr sciErr;
  sciErr = createMatrixOfDouble(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut, iRows, iCols, pdblValue);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  return SWIG_OK;
}
}

%fragment("SWIG_" "CreateScilabVariable" "_" {double}, "wrapper") {
SWIGINTERN int
SWIG_CreateScilabVariable_double(void *pvApiCtx, const char* psVariableName, const double dVariableValue) {
  SciErr sciErr;
  sciErr = createNamedMatrixOfDouble(pvApiCtx, psVariableName, 1, 1, &dVariableValue);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }
  return SWIG_OK;
}
}
%endoffile
%includefile "/usr/local/share/swig/4.0.0/scilab/scifloat.swg" %beginfile
/*
 * FLOAT SCALAR
 */

%fragment("SWIG_" "AsVal" "_" {float}, "header", fragment="SWIG_" "AsVal" "_" {double}) {
SWIGINTERN int
SWIG_AsVal_float (SwigSciObject iVar, float *pfValue) {
  double dblValue = 0.0;
  if(SWIG_AsVal_double (iVar, &dblValue) != SWIG_OK) {
    return SWIG_ERROR;
  }
  if (pfValue)
    *pfValue = (float) dblValue;
  return SWIG_OK;
}
}

%fragment("SWIG_" "From" "_" {float}, "header") {
SWIGINTERN int
SWIG_From_float  (float flValue) {
  if (createScalarDouble(pvApiCtx, SWIG_NbInputArgument(pvApiCtx)
    + SWIG_Scilab_GetOutputPosition(), (double)flValue))
    return SWIG_ERROR;
  return SWIG_OK;
}
}

%fragment("SWIG_SciDouble_AsFloatArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDouble_AsFloatArrayAndSize(void *pvApiCtx, int iVar, int *iRows, int *iCols, float **pfValue, char *fname) {
  SciErr sciErr;
  int *piAddrVar = NULL;
  double *pdValue = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (isDoubleType(pvApiCtx, piAddrVar) && !isVarComplex(pvApiCtx, piAddrVar)) {
    int i;

    sciErr = getMatrixOfDouble(pvApiCtx, piAddrVar, iRows, iCols, &pdValue);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }

    *pfValue = (float *) malloc((*iRows) * (*iCols) * sizeof(float));
    for (i=0; i < (*iRows) * (*iCols); i++)
      (*pfValue)[i] = (float) pdValue[i];

    return SWIG_OK;
  }
  else {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A real matrix expected.\n"), fname, iVar);
    return SWIG_ERROR;
  }
}
}

%fragment("SWIG_SciDouble_FromFloatArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDouble_FromFloatArrayAndSize(void *pvApiCtx, int iVarOut, int iRows, int iCols, float *pfValue) {
  SciErr sciErr;
  double *pdValue;
  int i;

  pdValue = (double *) malloc(iRows * iCols * sizeof(double));
  for (i = 0; i < iRows * iCols; i++)
    pdValue[i] = pfValue[i];

  sciErr = createMatrixOfDouble(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut, iRows, iCols, pdValue);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  free(pdValue);
  return SWIG_OK;
}
}
%endoffile

%includefile "/usr/local/share/swig/4.0.0/scilab/scilonglong.swg" %beginfile
/*
 * C-type: long long
 * Scilab 5 type: NONE
 * Scilab 6 type: int64
 */
%fragment("SWIG_" "AsVal" "_" {long long}, "header", fragment="SWIG_SciInt64_ToLongLong") {
#define SWIG_AsVal_long_SS_long(scilabValue, valuePointer) SWIG_SciInt64_ToLongLong(pvApiCtx, scilabValue, valuePointer, SWIG_Scilab_GetFuncName())
}
%fragment("SWIG_SciInt64_ToLongLong", "header") {
SWIGINTERN int
SWIG_SciInt64_ToLongLong(void *pvApiCtx, int iVar, long long *pllValue, char *fname) {
  Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Scilab 5.X does not manage '%s' data type.\n"), "SWIG_SciInt64_ToLongLong", "int64");
  return SWIG_ERROR;
}
}

%fragment("SWIG_" "From" "_" {long long}, "header", fragment="SWIG_SciInt64_FromLongLong") {

}
%fragment("SWIG_SciInt64_FromLongLong", "header") {
SWIGINTERN int
SWIG_SciInt64_FromLongLong(void *pvApiCtx, int iVarOut, long long llValue) {
  Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Scilab 5.X does not manage '%s' data type.\n"), "SWIG_SciInt64_ToLongLong", "int64");
  return SWIG_ERROR;
}
}

/*
 * C-type: unsigned long long
 * Scilab 5 type: NONE
 * Scilab 6 type: uint64
 */
%fragment("SWIG_" "AsVal" "_" {unsigned long long}, "header", fragment="SWIG_SciUint64_ToUnsignedLongLong") {

}
%fragment("SWIG_SciUint64_ToUnsignedLongLong", "header") {
SWIGINTERN int
SWIG_SciUint64_ToUnsignedLongLong(void *pvApiCtx, int iVar, unsigned long long *pullValue, char *fname) {
  Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Scilab 5.X does not manage '%s' data type.\n"), "SWIG_SciUint64_ToLongLong", "uint64");
  return SWIG_ERROR;
}
}

%fragment("SWIG_" "From" "_" {unsigned long long}, "header", fragment="SWIG_SciUint64_FromUnsignedLongLong") {

}
%fragment("SWIG_SciUint64_FromUnsignedLongLong", "header") {
SWIGINTERN int
SWIG_SciUint64_FromUnsignedLongLong(void *pvApiCtx, int iVarOut, unsigned long long llValue) {
  Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Scilab 5.X does not manage '%s' data type.\n"), "SWIG_SciUint64_ToLongLong", "uint64");
  return SWIG_ERROR;
}
}

%endoffile

%includefile "/usr/local/share/swig/4.0.0/scilab/sciint.swg" %beginfile
/*
 * C-type: int
 * Scilab type: double or int32
 */

%fragment("SWIG_" "AsVal" "_" {int}, "header", fragment="SWIG_SciDoubleOrInt32_AsInt", fragment="<limits.h>") {
#define SWIG_AsVal_int(scilabValue, valuePointer) SWIG_SciDoubleOrInt32_AsInt(pvApiCtx, scilabValue, valuePointer, SWIG_Scilab_GetFuncName())
}
%fragment("SWIG_SciDoubleOrInt32_AsInt", "header") {
SWIGINTERN int
SWIG_SciDoubleOrInt32_AsInt(void *pvApiCtx, SwigSciObject iVar, int *piValue, char *fname)
{
  SciErr sciErr;
  int iType = 0;
  int iRows = 0;
  int iCols = 0;
  int *piAddrVar = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  sciErr = getVarType(pvApiCtx, piAddrVar, &iType);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (iType == sci_ints) {
    if (piValue) {
      int iPrec = 0;
      int *piData = NULL;

      sciErr = getMatrixOfIntegerPrecision(pvApiCtx, piAddrVar, &iPrec);
      if (sciErr.iErr) {
        printError(&sciErr, 0);
        return SWIG_ERROR;
      }
      if (iPrec != SCI_INT32) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 32-bit signed integer or a double expected.\n"), fname, iVar);
        return SWIG_TypeError;
      }
      sciErr = getMatrixOfInteger32(pvApiCtx, piAddrVar, &iRows, &iCols, &piData);
      if (sciErr.iErr) {
        printError(&sciErr, 0);
        return SWIG_ERROR;
      }
      if (iRows * iCols != 1) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong size for input argument #%d: A 32-bit signed integer or a double expected.\n"), fname, iVar);
        return SWIG_TypeError;
      }
      *piValue = *piData;
    }
  }
  else if (iType == sci_matrix) {
    if (piValue) {
      double *pdData = NULL;
      double dValue = 0.0f;
      sciErr = getMatrixOfDouble(pvApiCtx, piAddrVar, &iRows, &iCols, &pdData);
      if (sciErr.iErr) {
        printError(&sciErr, 0);
        return SWIG_ERROR;
      }
      if (iRows * iCols != 1) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong size for input argument #%d: A 32-bit signed integer or a double expected.\n"), fname, iVar);
        return SWIG_TypeError;
      }
      dValue = *pdData;
      if (dValue != floor(dValue)) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Incorrect value for input argument #%d: The double value cannot be converted to a 32-bit signed integer.\n"), fname, iVar);
        return SWIG_ValueError;
      }
      if ((dValue < INT_MIN) || (dValue > INT_MAX)) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Overflow error for input argument #%d: The double value cannot be converted to a 32-bit signed integer.\n"), fname, iVar);
        return SWIG_OverflowError;
      }
      *piValue = (int) dValue;
    }
  }
  else {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 32-bit signed integer or a double expected.\n"), fname, iVar);
    return SWIG_TypeError;
  }

  return SWIG_OK;
}
}

%fragment("SWIG_" "From" "_" {int}, "header", fragment="SWIG_SciDouble_FromInt") {
#define SWIG_From_int(scilabValue) SWIG_SciDouble_FromInt(pvApiCtx, SWIG_Scilab_GetOutputPosition(), scilabValue, SWIG_Scilab_GetFuncName())
}
%fragment("SWIG_SciDouble_FromInt", "header") {
SWIGINTERN int
SWIG_SciDouble_FromInt(void *pvApiCtx, int iVarOut, int iValue, char *fname){
  if (createScalarDouble(pvApiCtx, SWIG_NbInputArgument(pvApiCtx)
    + iVarOut, (double) iValue))
    return SWIG_ERROR;
  return SWIG_OK;
}
}

/*
 * C-type: int[]
 * Scilab type: double or int32 matrix
 */
%fragment("SWIG_SciDoubleOrInt32_AsIntArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDoubleOrInt32_AsIntArrayAndSize(void *pvApiCtx, int iVar, int *iRows, int *iCols, int **piValue, char *fname) {
  SciErr sciErr;
  int iType = 0;
  int *piAddrVar = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  sciErr = getVarType(pvApiCtx, piAddrVar, &iType);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (iType == sci_matrix) {
    double *pdData = NULL;
    int size = 0;
    int i;

    sciErr = getMatrixOfDouble(pvApiCtx, piAddrVar, iRows, iCols, &pdData);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }

    size = (*iRows) * (*iCols);
    *piValue = (int*) malloc(size * sizeof(int*));
    for (i = 0; i < size; i++)
      (*piValue)[i] = (int) pdData[i];
  }
  else if (iType == sci_ints) {
    int iPrec = 0;
    sciErr = getMatrixOfIntegerPrecision(pvApiCtx, piAddrVar, &iPrec);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
    if (iPrec != SCI_INT32) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 32-bit signed integer or a double matrix expected.\n"), fname, iVar);
      return SWIG_ERROR;
    }
    sciErr = getMatrixOfInteger32(pvApiCtx, piAddrVar, iRows, iCols, piValue);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
  }
  else {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 32-bit signed integer or a double matrix expected.\n"), fname, iVar);
    return SWIG_ERROR;
  }
  return SWIG_OK;
}
}

%fragment("SWIG_SciDouble_FromIntArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDouble_FromIntArrayAndSize(void *pvApiCtx, int iVarOut, int iRows, int iCols, const int *piData) {
  SciErr sciErr;
  double *pdValues = NULL;
  int i;

  pdValues = (double*) malloc(iRows * iCols * sizeof(double));
  for (i=0; i<iRows * iCols; i++)
    pdValues[i] = piData[i];

  sciErr = createMatrixOfDouble(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut, iRows, iCols, pdValues);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    free(pdValues);
    return SWIG_ERROR;
  }

  free(pdValues);
  return SWIG_OK;
}
}

%fragment("SWIG_" "CreateScilabVariable" "_" {int}, "wrapper") {
SWIGINTERN int
SWIG_CreateScilabVariable_int(void *pvApiCtx, const char* psVariableName, const int iVariableValue) {
  SciErr sciErr;
  sciErr = createNamedMatrixOfInteger32(pvApiCtx, psVariableName, 1, 1, &iVariableValue);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }
  return SWIG_OK;
}
}
%endoffile
%includefile "/usr/local/share/swig/4.0.0/scilab/sciunsignedint.swg" %beginfile
/*
 * C-type: unsigned int
 * Scilab type: double or uint32
 */
%fragment("SWIG_" "AsVal" "_" {unsigned int}, "header", fragment="SWIG_SciDoubleOrUint32_AsUnsignedInt", fragment="<limits.h>") {
#define SWIG_AsVal_unsigned_SS_int(scilabValue, valuePointer) SWIG_SciDoubleOrUint32_AsUnsignedInt(pvApiCtx, scilabValue, valuePointer, SWIG_Scilab_GetFuncName())
}
%fragment("SWIG_SciDoubleOrUint32_AsUnsignedInt", "header") {
SWIGINTERN int
SWIG_SciDoubleOrUint32_AsUnsignedInt(void *pvApiCtx, int iVar, unsigned int *puiValue, char *fname) {
  SciErr sciErr;
  int iType = 0;
  int iRows = 0;
  int iCols = 0;
  int iPrec = 0;
  int *piAddrVar = NULL;
  unsigned int *puiData = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  sciErr = getVarType(pvApiCtx, piAddrVar, &iType);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (iType == sci_ints) {
    if (puiValue) {
      sciErr = getMatrixOfIntegerPrecision(pvApiCtx, piAddrVar, &iPrec);
      if (sciErr.iErr) {
        printError(&sciErr, 0);
        return SWIG_ERROR;
      }
      if (iPrec != SCI_UINT32) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 32-bit unsigned integer or a double expected.\n"), fname, iVar);
        return SWIG_ERROR;
      }

      sciErr = getMatrixOfUnsignedInteger32(pvApiCtx, piAddrVar, &iRows, &iCols, &puiData);
      if (sciErr.iErr) {
        printError(&sciErr, 0);
        return SWIG_ERROR;
      }
      if (iRows * iCols != 1) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong size for input argument #%d: A 32-bit unsigned integer or a double expected.\n"), fname, iVar);
        return SWIG_ERROR;
      }
      *puiValue = *puiData;
    }
  }
  else if (iType == sci_matrix) {
    if (puiValue) {
      double *pdData = NULL;
      double dValue = 0.0f;
      sciErr = getMatrixOfDouble(pvApiCtx, piAddrVar, &iRows, &iCols, &pdData);
      if (sciErr.iErr) {
        printError(&sciErr, 0);
        return SWIG_ERROR;
      }
      if (iRows * iCols != 1) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong size for input argument #%d: A 32-bit unsigned integer or a double expected.\n"), fname, iVar);
        return SWIG_TypeError;
      }
      dValue = *pdData;
      if (dValue != floor(dValue)) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Incorrect value for input argument #%d: The double value cannot be converted to a 32-bit unsigned integer.\n"), fname, iVar);
        return SWIG_ValueError;
      }
      if ((dValue < 0) || (dValue > UINT_MAX)) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Overflow error for input argument #%d: The double value cannot be converted to a 32-bit unsigned integer.\n"), fname, iVar);
        return SWIG_OverflowError;
      }
      *puiValue = (unsigned int) dValue;
    }
  }
  else {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 32-bit unsigned integer or a double expected.\n"), fname, iVar);
    return SWIG_ERROR;
  }

  return SWIG_OK;
}
}

%fragment("SWIG_" "From" "_" {unsigned int}, "header", fragment="SWIG_SciDouble_FromUnsignedInt") {
#define SWIG_From_unsigned_SS_int(scilabValue) SWIG_SciDouble_FromUnsignedInt(pvApiCtx, SWIG_Scilab_GetOutputPosition(), scilabValue, SWIG_Scilab_GetFuncName())
}
%fragment("SWIG_SciDouble_FromUnsignedInt", "header") {
SWIGINTERN int
SWIG_SciDouble_FromUnsignedInt(void *pvApiCtx, int iVarOut, unsigned int uiValue, char *fname) {
  if (createScalarDouble(pvApiCtx,
    SWIG_NbInputArgument(pvApiCtx) + iVarOut, (double) uiValue))
    return SWIG_ERROR;
  return SWIG_OK;
}
}

/*
 * C-type: unsigned int[]
 * Scilab type: uint32 vector
 */
%fragment("SWIG_SciDoubleOrUint32_AsUnsignedIntArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDoubleOrUint32_AsUnsignedIntArrayAndSize(void *pvApiCtx, int iVar, int *iRows, int *iCols, unsigned int **puiValue, char *fname) {
  SciErr sciErr;
  int iType = 0;
  int iPrec = 0;
  int *piAddrVar = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  sciErr = getVarType(pvApiCtx, piAddrVar, &iType);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (iType == sci_matrix) {
    double *pdData = NULL;
    int size = 0;
    int i;

    sciErr = getMatrixOfDouble(pvApiCtx, piAddrVar, iRows, iCols, &pdData);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }

    size = (*iRows) * (*iCols);
    *puiValue = (unsigned int*) malloc(size * sizeof(int*));
    for (i = 0; i < size; i++)
      (*puiValue)[i] = (unsigned int) pdData[i];
  }
  else if (iType == sci_ints) {
    sciErr = getMatrixOfIntegerPrecision(pvApiCtx, piAddrVar, &iPrec);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }

    if (iPrec != SCI_UINT32) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 32-bit unsigned integer or a double vector expected.\n"), fname, iVar);
      return SWIG_ERROR;
    }

    sciErr = getMatrixOfUnsignedInteger32(pvApiCtx, piAddrVar, iRows, iCols, puiValue);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
  }
  else {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 32-bit unsigned integer or a double vector expected.\n"), fname, iVar);
    return SWIG_ERROR;
  }

  return SWIG_OK;
}
}

%fragment("SWIG_SciDouble_FromUnsignedIntArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDouble_FromUnsignedIntArrayAndSize(void *pvApiCtx, int iVarOut, int iRows, int iCols, unsigned int *puiValues) {
  SciErr sciErr;
  double *pdValues = NULL;
  int i;

  pdValues = (double*) malloc(iRows * iCols * sizeof(double));
  for (i=0; i<iRows * iCols; i++)
    pdValues[i] = puiValues[i];

  sciErr = createMatrixOfDouble(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut, iRows, iCols, pdValues);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    free(pdValues);
    return SWIG_ERROR;
  }

  free(pdValues);
  return SWIG_OK;
}
}

%fragment("SWIG_" "CreateScilabVariable" "_" {uint}, "wrapper") {
SWIGINTERN int
SWIG_CreateScilabVariable_uint(void *pvApiCtx, const char* psVariableName, const unsigned int uiVariableValue) {
  SciErr sciErr;
  sciErr = createNamedMatrixOfUnsignedInteger32(pvApiCtx, psVariableName, 1, 1, &uiVariableValue);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }
  return SWIG_OK;
}
}

%endoffile

%includefile "/usr/local/share/swig/4.0.0/scilab/scilong.swg" %beginfile
/*
 * C-type: long
 * Scilab type: double or int32
 */

%fragment("SWIG_" "AsVal" "_" {long}, "header", fragment="SWIG_SciDoubleOrInt32_AsLong", fragment="<limits.h>") {
#define SWIG_AsVal_long(scilabValue, valuePointer) SWIG_SciDoubleOrInt32_AsLong(pvApiCtx, scilabValue, valuePointer, SWIG_Scilab_GetFuncName());
}
%fragment("SWIG_SciDoubleOrInt32_AsLong", "header") {
SWIGINTERN int
SWIG_SciDoubleOrInt32_AsLong(void *pvApiCtx, SwigSciObject iVar, long *plValue, char *fname) {
  SciErr sciErr;
  int iType = 0;
  int iRows = 0;
  int iCols = 0;
  int *piAddrVar = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  sciErr = getVarType(pvApiCtx, piAddrVar, &iType);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (iType == sci_ints) {
    int iPrec = 0;
    int *piData = NULL;

    sciErr = getMatrixOfIntegerPrecision(pvApiCtx, piAddrVar, &iPrec);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
    if (iPrec != SCI_INT32) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 32-bit signed integer or a double expected.\n"), fname, iVar);
      return SWIG_TypeError;
    }
    sciErr = getMatrixOfInteger32(pvApiCtx, piAddrVar, &iRows, &iCols, &piData);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
    if (iRows * iCols != 1) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong size for input argument #%d: A 32-bit signed integer or a double expected.\n"), fname, iVar);
      return SWIG_TypeError;
    }
    *plValue = (long) *piData;
  }
  else if (iType == sci_matrix) {
    double *pdData = NULL;
    double dValue = 0.0f;

    sciErr = getMatrixOfDouble(pvApiCtx, piAddrVar, &iRows, &iCols, &pdData);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
    if (iRows * iCols != 1) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong size for input argument #%d: A 32-bit signed integer or a double expected.\n"), fname, iVar);
      return SWIG_TypeError;
    }
    dValue = *pdData;
    if (dValue != floor(dValue)) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Incorrect value for input argument #%d: The double value cannot be converted to a 32-bit signed integer.\n"), fname, iVar);
      return SWIG_ValueError;
    }
    if ((dValue < LONG_MIN) || (dValue > LONG_MAX)) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Overflow error for input argument #%d: The double value cannot be converted to a 32-bit signed integer.\n"), fname, iVar);
      return SWIG_OverflowError;
    }
    *plValue = (long) dValue;
  }
  else {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 32-bit signed integer or a double expected.\n"), fname, iVar);
    return SWIG_TypeError;
  }

  return SWIG_OK;
}
}

%fragment("SWIG_" "From" "_" {long}, "header", fragment="SWIG_SciDouble_FromLong") {
#define SWIG_From_long(scilabValue) SWIG_SciDouble_FromLong(pvApiCtx, SWIG_Scilab_GetOutputPosition(), scilabValue, SWIG_Scilab_GetFuncName())
}
%fragment("SWIG_SciDouble_FromLong", "header") {
SWIGINTERN int
SWIG_SciDouble_FromLong(void *pvApiCtx, int iVarOut, long lValue, char *fname) {
  if (createScalarDouble(pvApiCtx,
    SWIG_NbInputArgument(pvApiCtx) + iVarOut, (double) lValue))
    return SWIG_ERROR;
  return SWIG_OK;
}
}


%fragment("SWIG_SciDouble_FromLongArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDouble_FromLongArrayAndSize(void *pvApiCtx, int iVarOut, int iRows, int iCols, const long *plData) {
  SciErr sciErr;
  int i;
  double *pdValues = NULL;

  pdValues = (double*) malloc(iRows * iCols * sizeof(double));
  for (i=0; i<iRows * iCols; i++) {
    pdValues[i] = plData[i];
  }

  sciErr = createMatrixOfDouble(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut, iRows, iCols, pdValues);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    free(pdValues);
    return SWIG_ERROR;
  }
  free(pdValues);
  return SWIG_OK;
}
}

%endoffile
%includefile "/usr/local/share/swig/4.0.0/scilab/sciunsignedlong.swg" %beginfile
/*
 * C-type: unsigned long
 * Scilab type: see unsigned int
 */

%fragment("SWIG_" "AsVal" "_" {unsigned long}, "header", fragment="SWIG_UnsignedInt_AsUnsignedLong") {

}
%fragment("SWIG_UnsignedInt_AsUnsignedLong", "header", fragment="SWIG_" "AsVal" "_" {unsigned int}) {
SWIGINTERN int
SWIG_UnsignedInt_AsUnsignedLong(void *pvApiCtx, SwigSciObject iVar, unsigned long *pulValue, char *fname) {
  unsigned int uiValue = 0;
  if(SWIG_AsVal_unsigned_SS_int(iVar, &uiValue) != SWIG_OK) {
    return SWIG_ERROR;
  }
  *pulValue = (unsigned long) uiValue;
  return SWIG_OK;
}
}

%fragment("SWIG_" "From" "_" {unsigned long}, "header", fragment="SWIG_UnsignedInt_FromUnsignedLong") {

}
%fragment("SWIG_UnsignedInt_FromUnsignedLong", "header", fragment="SWIG_" "From" "_" {unsigned int}) {
SWIGINTERN int
SWIG_UnsignedInt_FromUnsignedLong(void *pvApiCtx, int iVarOut, unsigned long ulValue, char *fname) {
  return SWIG_From_unsigned_SS_int((unsigned int)ulValue);
}
}

%fragment("SWIG_SciDouble_FromUnsignedLongArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDouble_FromUnsignedLongArrayAndSize(void *pvApiCtx, int iVarOut, int iRows, int iCols, const unsigned long *pulValues) {
  SciErr sciErr;
  double *pdValues = NULL;
  int i;

  pdValues = (double*) malloc(iRows * iCols * sizeof(double));
  for (i=0; i<iRows * iCols; i++) {
    pdValues[i] = pulValues[i];
  }

  sciErr = createMatrixOfDouble(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut, iRows, iCols, pdValues);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    free(pdValues);
    return SWIG_ERROR;
  }

  free(pdValues);
  return SWIG_OK;
}
}
%endoffile

%includefile "/usr/local/share/swig/4.0.0/scilab/scishort.swg" %beginfile
/*
 * C-type: short
 * Scilab type: double or int16
 */

%fragment("SWIG_" "AsVal" "_" {short}, "header", fragment="SWIG_SciDoubleOrInt16_AsShort", fragment="<limits.h>") {

}
%fragment("SWIG_SciDoubleOrInt16_AsShort", "header") {
SWIGINTERN int
SWIG_SciDoubleOrInt16_AsShort(void *pvApiCtx, int iVar, short *psValue, char *fname) {
  SciErr sciErr;
  int iType = 0;
  int iRows = 0;
  int iCols = 0;
  int *piAddrVar = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  sciErr = getVarType(pvApiCtx, piAddrVar, &iType);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (iType == sci_ints) {
    int iPrec = 0;
    short *psData = NULL;

    sciErr = getMatrixOfIntegerPrecision(pvApiCtx, piAddrVar, &iPrec);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
    if (iPrec != SCI_INT16) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 16-bit signed integer or a double expected.\n"), fname, iVar);
      return SWIG_TypeError;
    }
    sciErr = getMatrixOfInteger16(pvApiCtx, piAddrVar, &iRows, &iCols, &psData);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
    if (iRows * iCols != 1) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong size for input argument #%d: A 16-bit signed integer or a double expected.\n"), fname, iVar);
      return SWIG_TypeError;
    }
    *psValue = *psData;
  }
  else if (iType == sci_matrix) {
    double *pdData = NULL;
    double dValue = 0.0f;

    sciErr = getMatrixOfDouble(pvApiCtx, piAddrVar, &iRows, &iCols, &pdData);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
    if (iRows * iCols != 1) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong size for input argument #%d: A 16-bit signed integer or a double expected.\n"), fname, iVar);
      return SWIG_TypeError;
    }
    dValue = *pdData;
    if (dValue != floor(dValue)) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Incorrect value for input argument #%d: The double value cannot be converted to a 16-bit signed integer.\n"), fname, iVar);
      return SWIG_ValueError;
    }
    if ((dValue < SHRT_MIN) || (dValue > SHRT_MAX)) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Overflow error for input argument #%d: The double value cannot be converted to a 16-bit signed integer.\n"), fname, iVar);
      return SWIG_OverflowError;
    }
    *psValue = (short) dValue;
  }
  else {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 16-bit signed integer or a double expected.\n"), fname, iVar);
    return SWIG_TypeError;
  }

  return SWIG_OK;
}
}

%fragment("SWIG_" "From" "_" {short}, "header", fragment="SWIG_SciDouble_FromShort") {

}
%fragment("SWIG_SciDouble_FromShort", "header") {
SWIGINTERN int
SWIG_SciDouble_FromShort(void *pvApiCtx, int iVarOut, short sValue, char *fname) {
  if (createScalarDouble(pvApiCtx,
    SWIG_NbInputArgument(pvApiCtx) + iVarOut, (double) sValue))
    return SWIG_ERROR;
  return SWIG_OK;
}
}

/*
 * C-type: short[]
 * Scilab type: double or int16 matrix
 */
%fragment("SWIG_SciDoubleOrInt16_AsShortArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDoubleOrInt16_AsShortArrayAndSize(void *pvApiCtx, int iVar, int *iRows, int *iCols, short **psValue, char *fname) {
  SciErr sciErr;
  int iType = 0;
  int iPrec = 0;
  int *piAddrVar = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  sciErr = getVarType(pvApiCtx, piAddrVar, &iType);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (iType == sci_matrix) {
    double *pdData = NULL;
    int size = 0;
    int i;

    sciErr = getMatrixOfDouble(pvApiCtx, piAddrVar, iRows, iCols, &pdData);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }

    size = (*iRows) * (*iCols);
    *psValue = (short*) malloc(size * sizeof(int*));
    for (i = 0; i < size; i++)
      (*psValue)[i] = (short) pdData[i];
  }
  else if (iType == sci_ints) {
    int iPrec = 0;
    sciErr = getMatrixOfIntegerPrecision(pvApiCtx, piAddrVar, &iPrec);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
    if (iPrec != SCI_INT16) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 16-bit signed integer or a double matrix expected.\n"), fname, iVar);
      return SWIG_ERROR;
    }

    sciErr = getMatrixOfInteger16(pvApiCtx, piAddrVar, iRows, iCols, psValue);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
  }
  else {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 16-bit signed integer or a double matrix expected.\n"), fname, iVar);
    return SWIG_ERROR;
  }

  return SWIG_OK;
}
}
%fragment("SWIG_SciDouble_FromShortArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDouble_FromShortArrayAndSize(void *pvApiCtx, int iVarOut, int iRows, int iCols, short *psValue) {
  SciErr sciErr;
  int i;
  double *pdValues = NULL;

  pdValues = (double*) malloc(iRows * iCols * sizeof(double));
  for (i=0; i<iRows * iCols; i++)
    pdValues[i] = psValue[i];

  sciErr = createMatrixOfDouble(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut, iRows, iCols, pdValues);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    free(pdValues);
    return SWIG_ERROR;
  }

  free(pdValues);
  return SWIG_OK;
}
}

%endoffile
%includefile "/usr/local/share/swig/4.0.0/scilab/sciunsignedshort.swg" %beginfile
/*
 * C-type: unsigned short
 * Scilab type: double or uint16
 */
%fragment("SWIG_" "AsVal" "_" {unsigned short}, "header", fragment="SWIG_SciDoubleOrUint16_AsUnsignedShort", fragment="<limits.h>") {
#define SWIG_AsVal_unsigned_SS_short(scilabValue, valuePointer) SWIG_SciDoubleOrUint16_AsUnsignedShort(pvApiCtx, scilabValue, valuePointer, SWIG_Scilab_GetFuncName())
}
%fragment("SWIG_SciDoubleOrUint16_AsUnsignedShort", "header") {
SWIGINTERN int
SWIG_SciDoubleOrUint16_AsUnsignedShort(void *pvApiCtx, int iVar, unsigned short *pusValue, char *fname) {
  SciErr sciErr;
  int iType = 0;
  int iRows = 0;
  int iCols = 0;
  int iPrec = 0;
  int *piAddrVar = NULL;
  unsigned short *pusData = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  sciErr = getVarType(pvApiCtx, piAddrVar, &iType);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (iType == sci_ints) {
    if (pusValue) {
      sciErr = getMatrixOfIntegerPrecision(pvApiCtx, piAddrVar, &iPrec);
      if (sciErr.iErr) {
        printError(&sciErr, 0);
        return SWIG_ERROR;
      }
      if (iPrec != SCI_UINT16) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 16-bit unsigned integer or a double expected.\n"), fname, iVar);
        return SWIG_ERROR;
      }

      sciErr = getMatrixOfUnsignedInteger16(pvApiCtx, piAddrVar, &iRows, &iCols, &pusData);
      if (sciErr.iErr) {
        printError(&sciErr, 0);
        return SWIG_ERROR;
      }
      if (iRows * iCols != 1) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong size for input argument #%d: A 16-bit unsigned integer or a double expected.\n"), fname, iVar);
        return SWIG_ERROR;
      }
      *pusValue = *pusData;
    }
  }
  else if (iType == sci_matrix) {
    if (pusValue) {
      double *pdData = NULL;
      double dValue = 0.0f;
      sciErr = getMatrixOfDouble(pvApiCtx, piAddrVar, &iRows, &iCols, &pdData);
      if (sciErr.iErr) {
        printError(&sciErr, 0);
        return SWIG_ERROR;
      }
      if (iRows * iCols != 1) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong size for input argument #%d: A 16-bit unsigned integer or a double expected.\n"), fname, iVar);
        return SWIG_TypeError;
      }
      dValue = *pdData;
      if (dValue != floor(dValue)) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Incorrect value for input argument #%d: The double value cannot be converted to a 16-bit unsigned integer.\n"), fname, iVar);
        return SWIG_ValueError;
      }
      if ((dValue < 0) || (dValue > USHRT_MAX)) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Overflow error for input argument #%d: The double value cannot be converted to a 16-bit unsigned integer.\n"), fname, iVar);
        return SWIG_OverflowError;
      }
      *pusValue = (unsigned short) dValue;
    }
  }
  else {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 16-bit unsigned integer or a double expected.\n"), fname, iVar);
    return SWIG_ERROR;
  }

  return SWIG_OK;
}
}

%fragment("SWIG_" "From" "_" {unsigned short}, "header", fragment="SWIG_SciDouble_FromUnsignedShort") {
#define SWIG_From_unsigned_SS_short(scilabValue) SWIG_SciDouble_FromUnsignedShort(pvApiCtx, SWIG_Scilab_GetOutputPosition(), scilabValue, SWIG_Scilab_GetFuncName())
}
%fragment("SWIG_SciDouble_FromUnsignedShort", "header") {
SWIGINTERN int
SWIG_SciDouble_FromUnsignedShort(void *pvApiCtx, int iVarOut, unsigned short usValue, char *fname) {
  if (createScalarDouble(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut, (double) usValue))
    return SWIG_ERROR;
  return SWIG_OK;
}
}

/*
 * C-type: unsigned short[]
 * Scilab type: uint16 vector
 */
%fragment("SWIG_SciDoubleOrUint16_AsUnsignedShortArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDoubleOrUint16_AsUnsignedShortArrayAndSize(void *pvApiCtx, int iVar, int *iRows, int *iCols, unsigned short **pusValue, char *fname) {
  SciErr sciErr;
  int iType = 0;
  int iPrec = 0;
  int *piAddrVar = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  sciErr = getVarType(pvApiCtx, piAddrVar, &iType);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (iType == sci_matrix) {
    double *pdData = NULL;
    int size = 0;
    int i;

    sciErr = getMatrixOfDouble(pvApiCtx, piAddrVar, iRows, iCols, &pdData);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }

    size = (*iRows) * (*iCols);
    *pusValue = (unsigned short*) malloc(size * sizeof(int*));
    for (i = 0; i < size; i++)
      (*pusValue)[i] = (unsigned short) pdData[i];
  }
  else if (iType == sci_ints) {
    sciErr = getMatrixOfIntegerPrecision(pvApiCtx, piAddrVar, &iPrec);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }

    if (iPrec != SCI_UINT16) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 16-bit unsigned integer or a double vector expected.\n"), fname, iVar);
      return SWIG_ERROR;
    }

    sciErr = getMatrixOfUnsignedInteger16(pvApiCtx, piAddrVar, iRows, iCols, pusValue);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
  }
  else {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 16-bit unsigned integer or a double vector expected.\n"), fname, iVar);
    return SWIG_ERROR;
  }

  return SWIG_OK;
}
}

%fragment("SWIG_SciDouble_FromUnsignedShortArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDouble_FromUnsignedShortArrayAndSize(void *pvApiCtx, int iVarOut, int iRows, int iCols, unsigned short *pusValues) {
  SciErr sciErr;
  double *pdValues = NULL;
  int i;

  pdValues = (double*) malloc(iRows * iCols * sizeof(double));
  for (i=0; i<iRows * iCols; i++)
    pdValues[i] = pusValues[i];

  sciErr = createMatrixOfDouble(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut, iRows, iCols, pdValues);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    free(pdValues);
    return SWIG_ERROR;
  }

  free(pdValues);
  return SWIG_OK;
}
}
%endoffile

%includefile "/usr/local/share/swig/4.0.0/scilab/scichar.swg" %beginfile
/*
 * C-type: char or char*
 * Scilab type: string
 */

/*
 * CHAR
 */

%fragment("SWIG_" "AsVal" "_" {char}, "header", fragment="SWIG_SciString_AsChar") {

}
%fragment("SWIG_SciString_AsChar", "header") {
SWIGINTERN int
SWIG_SciString_AsChar(void *pvApiCtx, int iVar, char *pcValue, char *fname) {
  SciErr sciErr;
  int *piAddrVar = NULL;
  char *pstValue = NULL;
  int iRet;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (isStringType(pvApiCtx, piAddrVar) == 0)
  {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A single string expected.\n"), fname, iVar);
      return SWIG_TypeError;
  }

  iRet = getAllocatedSingleString(pvApiCtx, piAddrVar, &pstValue);
  if (iRet) {
    return SWIG_ERROR;
  }

  if (pcValue != NULL) {
    *pcValue = pstValue[0];
  }

  freeAllocatedSingleString(pstValue);
  return SWIG_OK;
}
}

%fragment("SWIG_" "From" "_" {char}, "header", fragment="SWIG_SciString_FromChar") {

}
%fragment("SWIG_SciString_FromChar", "header") {
SWIGINTERN int
SWIG_SciString_FromChar(void *pvApiCtx, int iVarOut, char chValue) {
  char *pchValue = (char*)malloc(sizeof(char) * 2);
  pchValue[0] = chValue;
  pchValue[1] = '\0';

  if (createSingleString(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut, pchValue))
    return SWIG_ERROR;

  free(pchValue);
  return SWIG_OK;
}
}

/*
 * CHAR *
*/

%fragment("SWIG_AsCharArray", "header", fragment = "SWIG_SciString_AsCharPtr") {

}
%fragment("SWIG_SciString_AsCharPtr", "header") {
SWIGINTERN int
SWIG_SciString_AsCharPtr(void *pvApiCtx, int iVar, char *pcValue, int iLength, char *fname) {
  SciErr sciErr;
  int *piAddrVar = NULL;
  char* pcTmpValue = NULL;
  int iRet;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  iRet = getAllocatedSingleString(pvApiCtx, piAddrVar, &pcTmpValue);
  if (iRet) {
    return SWIG_ERROR;
  }

  if (pcValue != NULL) {
    strncpy(pcValue, pcTmpValue, iLength);
  }

  freeAllocatedSingleString(pcTmpValue);
  return SWIG_OK;
}
}

%fragment("SWIG_AsCharPtrAndSize", "header", fragment = "SWIG_SciString_AsCharPtrAndSize") {

}
%fragment("SWIG_SciString_AsCharPtrAndSize", "header") {
SWIGINTERN int
SWIG_SciString_AsCharPtrAndSize(void *pvApiCtx, int iVar, char **pcValue, size_t *piLength, int *alloc, char *fname) {
  SciErr sciErr;
  int *piAddrVar = NULL;
  char *pstString = NULL;
  int iRows = 0;
  int iCols = 0;
  int iLen = 0;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (isScalar(pvApiCtx, piAddrVar) == 0 || isStringType(pvApiCtx, piAddrVar) == 0)
  {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A single string expected.\n"), fname, iVar);
      return SWIG_TypeError;
  }

  sciErr = getMatrixOfString(pvApiCtx, piAddrVar, &iRows, &iCols, &iLen, NULL);
  if (sciErr.iErr)
  {
      printError(&sciErr, 0);
      return SWIG_ERROR;
  }

  pstString = (new char[iLen + 1]());

  sciErr = getMatrixOfString(pvApiCtx, piAddrVar, &iRows, &iCols, &iLen, &pstString);
  if (sciErr.iErr)
  {
      printError(&sciErr, 0);
      return SWIG_ERROR;
  }

  // TODO: return SWIG_ERROR if pcValue NULL (now returning SWIG_ERROR fails some typechecks)
  if (pcValue) {
    *pcValue = pstString;
  }

  if (alloc != NULL) {
    *alloc = SWIG_NEWOBJ;
  }

  if (piLength != NULL) {
    *piLength = strlen(pstString);
  }

  return SWIG_OK;
}
}

%fragment("SWIG_FromCharPtr", "header", fragment = "SWIG_SciString_FromCharPtr") {

}
%fragment("SWIG_SciString_FromCharPtr", "header") {
SWIGINTERN int
SWIG_SciString_FromCharPtr(void *pvApiCtx, int iVarOut, const char *pchValue) {
  if (pchValue) {
    SciErr sciErr;
    const char* pstStrings[1];
    pstStrings[0] = pchValue;

    sciErr = createMatrixOfString(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut, 1, 1, pstStrings);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
  }
  else {
    int iRet = createEmptyMatrix(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut);
    if (iRet) {
      return SWIG_ERROR;
    }
  }

  return SWIG_OK;
}
}

/*
 * CHAR * ARRAY
 */

%fragment("SWIG_SciString_AsCharPtrArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciString_AsCharPtrArrayAndSize(void *pvApiCtx, int iVar, int *iRows, int *iCols, char ***charPtrArray, char *fname) {
  SciErr sciErr;
  int i = 0;
  int *piAddrVar = NULL;
  int* piLength = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  sciErr = getMatrixOfString(pvApiCtx, piAddrVar, iRows, iCols, NULL, NULL);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  piLength = (int*) malloc((*iRows) * (*iCols) * sizeof(int));

  sciErr = getMatrixOfString(pvApiCtx, piAddrVar, iRows, iCols, piLength, NULL);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  *charPtrArray = (char**) malloc((*iRows) * (*iCols) * sizeof(char*));
  for(i = 0 ; i < (*iRows) * (*iCols); i++) {
    (*charPtrArray)[i] = (char*) malloc(sizeof(char) * (piLength[i] + 1));
  }

  sciErr = getMatrixOfString(pvApiCtx, piAddrVar, iRows, iCols, piLength, *charPtrArray);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  free(piLength);
  return SWIG_OK;
}
}

%fragment("SWIG_SciString_FromCharPtrArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciString_FromCharPtrArrayAndSize(void *pvApiCtx, int iVarOut, int iRows, int iCols, char **charPtrArray) {
  SciErr sciErr;

  sciErr = createMatrixOfString(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut, iRows, iCols, (const char* const*) charPtrArray);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  return SWIG_OK;
}
}

%fragment("SWIG_FromCharPtrAndSize", "header", fragment = "SWIG_SciString_FromCharPtr") {

}


/*
 * Char* Scilab variable
 */

%fragment("SWIG_" "CreateScilabVariable" "_" {char}, "wrapper") {
SWIGINTERN int
SWIG_CreateScilabVariable_char(void *pvApiCtx, const char* psVariableName, const char cVariableValue) {
  SciErr sciErr;
  char sValue[2];
  const char* psStrings[1];

  sValue[0] = cVariableValue;
  sValue[1] = '\0';
  psStrings[0] = sValue;

  sciErr = createNamedMatrixOfString(pvApiCtx, psVariableName, 1, 1, psStrings);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }
  return SWIG_OK;
}
}

%fragment("SWIG_" "CreateScilabVariable" "_" {charptr}, "wrapper") {
SWIGINTERN int
SWIG_CreateScilabVariable_charptr(void *pvApiCtx, const char* psVariableName, const char* psVariableValue) {
  SciErr sciErr;
  const char* psStrings[1];
  psStrings[0] = psVariableValue;

  sciErr = createNamedMatrixOfString(pvApiCtx, psVariableName, 1, 1, psStrings);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }
  return SWIG_OK;
}
}
%endoffile
%includefile "/usr/local/share/swig/4.0.0/scilab/scisignedchar.swg" %beginfile
/*
 * C-type: signed char
 * Scilab type: double or int8
 */
%fragment("SWIG_" "AsVal" "_" {signed char}, "header", fragment="SWIG_SciDoubleOrInt8_AsSignedChar", fragment="<limits.h>") {

}
%fragment("SWIG_SciDoubleOrInt8_AsSignedChar", "header") {
SWIGINTERN int
SWIG_SciDoubleOrInt8_AsSignedChar(void *pvApiCtx, int iVar, signed char *pscValue, char *fname) {
  SciErr sciErr;
  int iType = 0;
  int iRows = 0;
  int iCols = 0;
  int iPrec = 0;
  int *piAddrVar = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  sciErr = getVarType(pvApiCtx, piAddrVar, &iType);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (iType == sci_ints) {
    char *pcData = NULL;

    sciErr = getMatrixOfIntegerPrecision(pvApiCtx, piAddrVar, &iPrec);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
    if (iPrec != SCI_INT8) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 8-bit signed integer or a double expected.\n"), fname, iVar);
      return SWIG_TypeError;
    }
    sciErr = getMatrixOfInteger8(pvApiCtx, piAddrVar, &iRows, &iCols, &pcData);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
    if (iRows * iCols != 1) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong size for input argument #%d: A 8-bit signed integer or a double expected.\n"), fname, iVar);
      return SWIG_TypeError;
    }
    *pscValue = *pcData;
  }
  else if (iType == sci_matrix) {
    double *pdData = NULL;
    double dValue = 0.0f;

    sciErr = getMatrixOfDouble(pvApiCtx, piAddrVar, &iRows, &iCols, &pdData);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
    if (iRows * iCols != 1) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong size for input argument #%d: A 8-bit signed integer or a double expected.\n"), fname, iVar);
      return SWIG_TypeError;
    }
    dValue = *pdData;
    if (dValue != floor(dValue)) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Incorrect value for input argument #%d: The double value cannot be converted to a 8-bit signed integer.\n"), fname, iVar);
      return SWIG_ValueError;
    }
    if ((dValue < SCHAR_MIN) || (dValue > SCHAR_MAX)) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Overflow error for input argument #%d: The double value cannot be converted to a 8-bit signed integer.\n"), fname, iVar);
      return SWIG_OverflowError;
    }
    *pscValue = (signed char) dValue;
  }
  else {
     Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 8-bit signed integer or a double expected.\n"), fname, iVar);
    return SWIG_TypeError;
  }

  return SWIG_OK;
}
}

%fragment("SWIG_" "From" "_" {signed char}, "header", fragment="SWIG_SciDouble_FromSignedChar") {

}
%fragment("SWIG_SciDouble_FromSignedChar", "header") {
SWIGINTERN int
SWIG_SciDouble_FromSignedChar(void *pvApiCtx, int iVarOut, signed char scValue) {
  if (createScalarDouble(pvApiCtx,
    SWIG_NbInputArgument(pvApiCtx) + iVarOut, (double) scValue))
    return SWIG_ERROR;
  return SWIG_OK;
}
}

/*
 * C-type: signed char[]
 * Scilab type: double or int8 matrix
 */
%fragment("SWIG_SciDoubleOrInt8_AsSignedCharArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDoubleOrInt8_AsSignedCharArrayAndSize(void *pvApiCtx, int iVar, int *iRows, int *iCols, signed char **pscValue, char *fname) {
  SciErr sciErr;
  int iType = 0;
  int *piAddrVar = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  sciErr = getVarType(pvApiCtx, piAddrVar, &iType);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (iType == sci_matrix) {
    double *pdData = NULL;
    int size = 0;
    int i;

    sciErr = getMatrixOfDouble(pvApiCtx, piAddrVar, iRows, iCols, &pdData);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }

    size = (*iRows) * (*iCols);
    *pscValue = (signed char*) malloc(size * sizeof(int*));
    for (i = 0; i < size; i++)
      (*pscValue)[i] = (signed char) pdData[i];
  }
  else if (iType == sci_ints) {
    int iPrec = 0;
    sciErr = getMatrixOfIntegerPrecision(pvApiCtx, piAddrVar, &iPrec);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
    if (iPrec != SCI_INT8) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 8-bit signed integer or a double matrix expected.\n"), fname, iVar);
      return SWIG_ERROR;
    }

    sciErr = getMatrixOfInteger8(pvApiCtx, piAddrVar, iRows, iCols, (char **)pscValue);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
  }
  else {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 8-bit signed integer or a double matrix expected.\n"), fname, iVar);
    return SWIG_ERROR;
  }
  return SWIG_OK;
}
}

%fragment("SWIG_SciDouble_FromSignedCharArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDouble_FromSignedCharArrayAndSize(void *pvApiCtx, int iVarOut, int iRows, int iCols, const signed char *pscValue) {
  SciErr sciErr;
  int i;
  double *pdValues = NULL;

  pdValues = (double*) malloc(iRows * iCols * sizeof(double));
  for (i=0; i<iRows * iCols; i++)
    pdValues[i] = pscValue[i];

  sciErr = createMatrixOfDouble(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut, iRows, iCols, pdValues);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    free(pdValues);
    return SWIG_ERROR;
  }

  free(pdValues);
  return SWIG_OK;
}
}
%endoffile
%includefile "/usr/local/share/swig/4.0.0/scilab/sciunsignedchar.swg" %beginfile
/*
 * C-type: unsigned char
 * Scilab type: double or uint8
 */
%fragment("SWIG_" "AsVal" "_" {unsigned char}, "header", fragment="SWIG_SciDoubleOrUint8_AsUnsignedChar", fragment="<limits.h>") {

}
%fragment("SWIG_SciDoubleOrUint8_AsUnsignedChar", "header") {
SWIGINTERN int
SWIG_SciDoubleOrUint8_AsUnsignedChar(void *pvApiCtx, int iVar, unsigned char *pucValue, char *fname) {
  SciErr sciErr;
  int iType = 0;
  int iRows = 0;
  int iCols = 0;
  int iPrec = 0;
  int *piAddrVar = NULL;
  unsigned char *pucData = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  sciErr = getVarType(pvApiCtx, piAddrVar, &iType);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (iType == sci_ints) {
    if (pucValue) {
      sciErr = getMatrixOfIntegerPrecision(pvApiCtx, piAddrVar, &iPrec);
      if (sciErr.iErr) {
        printError(&sciErr, 0);
        return SWIG_ERROR;
      }
      if (iPrec != SCI_UINT8) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 8-bit unsigned integer or a double expected.\n"), fname, iVar);
        return SWIG_ERROR;
      }

      sciErr = getMatrixOfUnsignedInteger8(pvApiCtx, piAddrVar, &iRows, &iCols, &pucData);
      if (sciErr.iErr) {
        printError(&sciErr, 0);
        return SWIG_ERROR;
      }
      if (iRows * iCols != 1) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong size for input argument #%d: A 8-bit unsigned integer or a double expected.\n"), fname, iVar);
        return SWIG_ERROR;
      }
      *pucValue = *pucData;
    }
  }
  else if (iType == sci_matrix) {
    if (pucValue) {
      double *pdData = NULL;
      double dValue = 0.0f;
      sciErr = getMatrixOfDouble(pvApiCtx, piAddrVar, &iRows, &iCols, &pdData);
      if (sciErr.iErr) {
        printError(&sciErr, 0);
        return SWIG_ERROR;
      }
      if (iRows * iCols != 1) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong size for input argument #%d: A 8-bit unsigned integer or a double expected.\n"), fname, iVar);
        return SWIG_TypeError;
      }
      dValue = *pdData;
      if (dValue != floor(dValue)) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Incorrect value for input argument #%d: The double value cannot be converted to a 8-bit unsigned integer.\n"), fname, iVar);
        return SWIG_ValueError;
      }
      if ((dValue < 0) || (dValue > UCHAR_MAX)) {
        Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Overflow error for input argument #%d: The double value cannot be converted to a 8-bit unsigned integer.\n"), fname, iVar);
        return SWIG_OverflowError;
      }
      *pucValue = (unsigned char) dValue;
    }
  }
  else {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 8-bit unsigned integer or a double expected.\n"), fname, iVar);
    return SWIG_ERROR;
  }

  return SWIG_OK;
}
}

%fragment("SWIG_" "From" "_" {unsigned char}, "header", fragment="SWIG_SciDouble_FromUnsignedChar") {

}
%fragment("SWIG_SciDouble_FromUnsignedChar", "header") {
SWIGINTERN int
SWIG_SciDouble_FromUnsignedChar(void *pvApiCtx, int iVarOut, unsigned char ucValue) {
  if (createScalarDouble(pvApiCtx,
    SWIG_NbInputArgument(pvApiCtx) + iVarOut, (double) ucValue))
    return SWIG_ERROR;
  return SWIG_OK;
}
}

/*
 * C-type: unsigned char[]
  * Scilab type: double or uint8 matrix
 */
%fragment("SWIG_SciDoubleOrUint8_AsUnsignedCharArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDoubleOrUint8_AsUnsignedCharArrayAndSize(void *pvApiCtx, int iVar, int *iRows, int *iCols, unsigned char **pucValue, char *fname) {
  SciErr sciErr;
  int iType = 0;
  int iPrec = 0;
  int *piAddrVar = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  sciErr = getVarType(pvApiCtx, piAddrVar, &iType);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (iType == sci_matrix) {
    double *pdData = NULL;
    int size = 0;
    int i;

    sciErr = getMatrixOfDouble(pvApiCtx, piAddrVar, iRows, iCols, &pdData);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }

    size = (*iRows) * (*iCols);
    *pucValue = (unsigned char*) malloc(size * sizeof(int*));
    for (i = 0; i < size; i++)
      (*pucValue)[i] = (unsigned char) pdData[i];
  }
  else if (iType == sci_ints) {
    sciErr = getMatrixOfIntegerPrecision(pvApiCtx, piAddrVar, &iPrec);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }

    if (iPrec != SCI_UINT8) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 8-bit unsigned integer or a double vector expected.\n"), fname, iVar);
      return SWIG_ERROR;
    }

    sciErr = getMatrixOfUnsignedInteger8(pvApiCtx, piAddrVar, iRows, iCols, pucValue);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
  }
  else {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A 8-bit unsigned integer or a double vector expected.\n"), fname, iVar);
    return SWIG_ERROR;
  }

  return SWIG_OK;
}
}

%fragment("SWIG_SciDouble_FromUnsignedCharArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciDouble_FromUnsignedCharArrayAndSize(void *pvApiCtx, int iVarOut, int iRows, int iCols, const unsigned char *pucValues) {
  SciErr sciErr;
  double *pdValues = NULL;
  int i;

  pdValues = (double*) malloc(iRows * iCols * sizeof(double));
  for (i=0; i<iRows * iCols; i++)
    pdValues[i] = pucValues[i];

  sciErr = createMatrixOfDouble(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut, iRows, iCols, pdValues);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    free(pdValues);
    return SWIG_ERROR;
  }

  free(pdValues);
  return SWIG_OK;
}
}
%endoffile

%includefile "/usr/local/share/swig/4.0.0/scilab/scimisctypes.swg" %beginfile
// Other primitive such as size_t and ptrdiff_t

/*
 * C-type: size_t
 * Scilab type: double or int32
 */

%fragment("SWIG_" "AsVal" "_" {size_t}, "header", fragment="SWIG_Int_AsSize") {
#define SWIG_AsVal_size_t(scilabValue, valuePointer) SWIG_Int_AsSize(pvApiCtx, scilabValue, valuePointer, SWIG_Scilab_GetFuncName())
}
%fragment("SWIG_Int_AsSize", "header", fragment="SWIG_" "AsVal" "_" {int})
{
SWIGINTERN int
SWIG_Int_AsSize(void *pvApiCtx, SwigSciObject iVar, size_t *piValue, char *fname) {
  int iValue = 0;
  if (SWIG_AsVal_int (iVar, &iValue) != SWIG_OK)
    return SWIG_ERROR;

  if (piValue)
    *piValue = (size_t) iValue;

  return SWIG_OK;
}
}

%fragment("SWIG_" "From" "_" {size_t}, "header", fragment="SWIG_Int_FromSize") {
#define SWIG_From_size_t(scilabValue) SWIG_Int_FromSize(pvApiCtx, SWIG_Scilab_GetOutputPosition(), scilabValue, SWIG_Scilab_GetFuncName())
}
%fragment("SWIG_Int_FromSize", "header", fragment="SWIG_" "From" "_" {int})
{
SWIGINTERN int
SWIG_Int_FromSize(void *pvApiCtx, int iVarOut, size_t iValue, char *fname) {
  return SWIG_From_int  ((int)iValue);
}
}

/*
 * C-type: ptrdiff_t
 * Scilab type: double or int32
 */

%fragment("SWIG_" "AsVal" "_" {ptrdiff_t}, "header", fragment="SWIG_Int_AsPtrDiff") {
#define SWIG_AsVal_ptrdiff_t(scilabValue, valuePointer) SWIG_Int_AsPtrDiff(pvApiCtx, scilabValue, valuePointer, SWIG_Scilab_GetFuncName())
}
%fragment("SWIG_Int_AsPtrDiff", "header", fragment="SWIG_" "AsVal" "_" {int})
{
SWIGINTERN int
SWIG_Int_AsPtrDiff(void *pvApiCtx, SwigSciObject iVar, ptrdiff_t *piValue, char *fname) {
  int iValue = 0;
  if (SWIG_AsVal_int (iVar, &iValue) != SWIG_OK)
    return SWIG_ERROR;

  if (piValue)
    *piValue = (ptrdiff_t) iValue;

  return SWIG_OK;
}
}

%fragment("SWIG_" "From" "_" {ptrdiff_t}, "header", fragment="SWIG_Int_FromPtrDiff") {
#define SWIG_From_ptrdiff_t(scilabValue) SWIG_Int_FromPtrDiff(pvApiCtx, SWIG_Scilab_GetOutputPosition(), scilabValue, SWIG_Scilab_GetFuncName())
}
%fragment("SWIG_Int_FromPtrDiff", "header", fragment="SWIG_" "From" "_" {int}) {
SWIGINTERN int
SWIG_Int_FromPtrDiff(void *pvApiCtx, int iVarOut, ptrdiff_t iValue, char *fname) {
  return SWIG_From_int  ((int)iValue);
}
}

%endoffile

%includefile "/usr/local/share/swig/4.0.0/scilab/scipointer.swg" %beginfile
/*
 * POINTER
 */
%fragment("SWIG_ConvertPtr", "header") {

}

%fragment("SWIG_NewPointerObj", "header") {

}

/*
 * FUNCTION POINTER
 */
%fragment("SWIG_ConvertFunctionPtr", "header") {

}

%fragment("SWIG_NewFunctionPtrObj", "header") {

}
// No fragment used here, the functions "SwigScilabPtrToObject" and "SwigScilabPtrFromObject" are defined in sciruntime.swg

/*
 * C++ member pointers, ie, member methods
 */
%fragment("SWIG_NewMemberObj", "header") {

}
%fragment("SWIG_ConvertMember", "header") {

}
%endoffile
%includefile "/usr/local/share/swig/4.0.0/scilab/scibool.swg" %beginfile
/*
 * C-type: bool
 * Scilab type: boolean scalar
 */
%fragment("SWIG_" "AsVal" "_" {bool}, "header") {
SWIGINTERN int
SWIG_AsVal_bool (SwigSciObject iVar, bool *pbValue) {
  SciErr sciErr;
  int iRet = 0;
  int *piAddrVar = NULL;
  int iTempValue = 0;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (!isBooleanType(pvApiCtx, piAddrVar)) {
      Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A boolean expected.\n"), SWIG_Scilab_GetFuncName(), iVar);
    return SWIG_ERROR;
  }

  if (!isScalar(pvApiCtx, piAddrVar)) {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong size for input argument #%d: A boolean expected.\n"), SWIG_Scilab_GetFuncName(), iVar);
    return SWIG_ERROR;
  }

  iRet = getScalarBoolean(pvApiCtx, piAddrVar, &iTempValue);
  if (iRet) {
    return SWIG_ERROR;
  }

  *pbValue = iTempValue;

  return SWIG_OK;
}
}

%fragment("SWIG_" "From" "_" {bool}, "header") {
SWIGINTERN int
SWIG_From_bool  (bool bValue) {
  if (createScalarBoolean(pvApiCtx, SWIG_NbInputArgument(pvApiCtx)
    + SWIG_Scilab_GetOutputPosition(), bValue))
    return SWIG_ERROR;
  return SWIG_OK;
}
}

/*
 * C-type: bool[]
 * Scilab type: boolean matrix
 */
%fragment("SWIG_SciBoolean_AsBoolArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciBoolean_AsBoolArrayAndSize(void *pvApiCtx, int iVar, int *iRows, int *iCols, bool **pbValue, char *fname) {
  SciErr sciErr;
  int *piAddrVar = NULL;
  int *piValue = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (isBooleanType(pvApiCtx, piAddrVar)) {
    int i;
    sciErr = getMatrixOfBoolean(pvApiCtx, piAddrVar, iRows, iCols, &piValue);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }

    *pbValue = (bool*) malloc((*iRows) * (*iCols) * sizeof(bool));
    for (i = 0; i < (*iRows) * (*iCols); i++)
      (*pbValue)[i] = piValue[i] != 0;
  }
  else {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A boolean matrix expected.\n"), fname, iVar);
    return SWIG_ERROR;
  }

  return SWIG_OK;
}
}

%fragment("SWIG_SciBoolean_FromBoolArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciBoolean_FromBoolArrayAndSize(void *pvApiCtx, int iVarOut, int iRows, int iCols, bool *pbValue) {
  SciErr sciErr;
  int *piValue = NULL;
  int i;

  piValue = (int*) malloc(iRows * iCols * sizeof(int));
  for (i = 0; i < iRows * iCols; i++)
    piValue[i] = pbValue[i];

  sciErr = createMatrixOfBoolean(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut, iRows, iCols, piValue);
  if(sciErr.iErr) {
    printError(&sciErr, 0);
    free(piValue);
    return SWIG_ERROR;
  }

  free(piValue);
  return SWIG_OK;
}
}

/*
 * C-type: int[]
 * Scilab type: boolean matrix
 */
%fragment("SWIG_SciBoolean_AsIntArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciBoolean_AsIntArrayAndSize(void *pvApiCtx, int iVar, int *iRows, int *iCols, int **piValue, char *fname) {
  SciErr sciErr;
  int *piAddrVar = NULL;

  sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  if (isBooleanType(pvApiCtx, piAddrVar)) {
    sciErr = getMatrixOfBoolean(pvApiCtx, piAddrVar, iRows, iCols, piValue);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return SWIG_ERROR;
    }
  }
  else {
    Scierror(SCILAB_API_ARGUMENT_ERROR, _("%s: Wrong type for input argument #%d: A boolean matrix expected.\n"), fname, iVar);
    return SWIG_ERROR;
  }

  return SWIG_OK;
}
}

%fragment("SWIG_SciBoolean_FromIntArrayAndSize", "header") {
SWIGINTERN int
SWIG_SciBoolean_FromIntArrayAndSize(void *pvApiCtx, int iVarOut, int iRows, int iCols, int *piValue) {
  SciErr sciErr;

  sciErr = createMatrixOfBoolean(pvApiCtx, SWIG_NbInputArgument(pvApiCtx) + iVarOut, iRows, iCols, piValue);
  if(sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }

  return SWIG_OK;
}
}
%endoffile

%endoffile

%includefile "/usr/local/share/swig/4.0.0/scilab/scienum.swg" %beginfile
/*
 * C-type: enum
 * Scilab type: double or int32
 */

%fragment("SWIG_" "AsVal" "_" {Enum}, "header", fragment="SWIG_Int_AsEnum") {
#define SWIG_AsVal_Enum(scilabValue, valuePointer) SWIG_Int_AsEnum(pvApiCtx, scilabValue, valuePointer, SWIG_Scilab_GetFuncName())
}
%fragment("SWIG_Int_AsEnum", "header", fragment="SWIG_SciDoubleOrInt32_AsInt") {
SWIGINTERN int
SWIG_Int_AsEnum(void *pvApiCtx, int iVar, int *enumValue, char *fname) {
  int iValue = 0;
  if (SWIG_SciDoubleOrInt32_AsInt(pvApiCtx, iVar, &iValue, fname) != SWIG_OK)
    return SWIG_ERROR;
  *enumValue = iValue;
  return SWIG_OK;
}
}

%fragment("SWIG_" "From" "_" {Enum}, "header", fragment="SWIG_Int_FromEnum") {
#define SWIG_From_Enum(scilabValue) SWIG_Int_FromEnum(pvApiCtx, SWIG_Scilab_GetOutputPosition(), scilabValue, SWIG_Scilab_GetFuncName())
}
%fragment("SWIG_Int_FromEnum", "header", fragment="SWIG_SciDouble_FromInt") {
SWIGINTERN int
SWIG_Int_FromEnum(void *pvApiCtx, int iVarOut, int enumValue, char *fname) {
  if (SWIG_SciDouble_FromInt(pvApiCtx, iVarOut, enumValue, fname) != SWIG_OK)
    return SWIG_ERROR;
  SWIG_Scilab_SetOutput(pvApiCtx, iVarOut);
  return SWIG_OK;
}
}
%endoffile

// Scilab object type









// Include the unified typemap library
%includefile "/usr/local/share/swig/4.0.0/typemaps/swigtypemaps.swg" %beginfile
/* -----------------------------------------------------------------------------
 * swigtypemaps.swg
 *
 * Unified Typemap Library frontend
 * ----------------------------------------------------------------------------- */

/*
  This file provides the frontend to the Unified Typemap Library.

  When using this library in a SWIG target language, you need to
  define a minimum set of fragments, specialize a couple of macros,
  and then include this file.

  Typically you will create a 'mytypemaps.swg' file in each target
  language, where you will have the following sections:

    === mytypemaps.swg ===

    //  Fragment section 
    %include <typemaps/fragments.swg>
    <include target language fragments>

    // Unified typemap section 
    <specialized the typemap library macros>
    %include <typemaps/swigtypemaps.swg>

    // Local typemap section 
    <add/replace extra target language typemaps>

    === mytypemaps.swg ===

  While we add more docs, please take a look at the following cases
  to see how you specialized the unified typemap library for a new
  target language:

      Lib/python/pytypemaps.swg
      Lib/tcl/tcltypemaps.swg
      Lib/ruby/rubytypemaps.swg
      Lib/perl5/perltypemaps.swg
    
*/



/* -----------------------------------------------------------------------------
 *   Language specialization section. 
 *
 *   Tune these macros for each language as needed.
 * ----------------------------------------------------------------------------- */

/*
  The SWIG target language object must be provided.
  For example in python you define:

    #define SWIG_Object PyObject *
*/





/*==== flags for new/convert methods ====*/














/*==== set output ====*/






/*==== set variable output  ====*/






/*==== append output ====*/










/*==== set constant ====*/










/*==== raise an exception ====*/










/*==== director output exception ====*/








/* -----------------------------------------------------------------------------
 *  Language independent definitions
 * ----------------------------------------------------------------------------- */













/* -----------------------------------------------------------------------------
 *  All the typemaps
 * ----------------------------------------------------------------------------- */



%includefile "/usr/local/share/swig/4.0.0/typemaps/exception.swg" %beginfile
/* -----------------------------------------------------------------------------
 * exceptions.swg
 *
 * This SWIG library file provides language independent exception handling
 * ----------------------------------------------------------------------------- */




/* macros for error manipulation */












/* setting an error */





%insert("runtime") {

#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 

}


/*
  You can use the SWIG_CATCH_STDEXCEPT macro with the %exception
  directive as follows:

  %exception {
    try {
      $action
    }
    catch (my_except& e) {
      ...
    }
    SWIG_CATCH_STDEXCEPT // catch std::exception
    catch (...) {
     SWIG_exception_fail(SWIG_UnknownError, "Unknown exception");
    }
  }
*/

%fragment("<stdexcept>");






























%endoffile
%includefile "/usr/local/share/swig/4.0.0/typemaps/swigtype.swg" %beginfile
/* -----------------------------------------------------------------------------
 * --- Input arguments --- 
 * ----------------------------------------------------------------------------- */
/* Pointers and arrays */
%typemap(in, noblock=1) SWIGTYPE *(void  *argp = 0, int res = 0) {
  res = SwigScilabPtrToObject(pvApiCtx, $input, &argp, $descriptor, $disown |  0 , SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
  $1 = ($ltype)(argp);
}
%typemap(freearg) SWIGTYPE * "";

%typemap(in, noblock=1) SWIGTYPE [] (void *argp = 0, int res = 0) {
  res = SwigScilabPtrToObject(pvApiCtx, $input, &argp, $descriptor, $disown |  0 , SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  } 
  $1 = ($ltype)(argp);
}
%typemap(freearg) SWIGTYPE [] "";


%typemap(in, noblock=1) SWIGTYPE *const&  (void *argp = 0, int res = 0, $*1_ltype temp) {
  res = SwigScilabPtrToObject(pvApiCtx, $input, &argp, $*descriptor, $disown |  0 , SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'"); 
  }
  temp = ($*ltype)(argp);
  $1 = ($1_ltype)(&temp);
}
%typemap(freearg) SWIGTYPE *const& "";


/* Reference */
%typemap(in, noblock=1) SWIGTYPE & (void *argp = 0, int res = 0) {
  res = SwigScilabPtrToObject(pvApiCtx, $input, &argp, $descriptor,  0 , SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
  if (!argp) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
  $1 = ($ltype)(argp);
}
%typemap(freearg) SWIGTYPE & "";















%typemap(in,noblock=1) const SWIGTYPE & (void *argp, int res = 0) {
  res = SwigScilabPtrToObject(pvApiCtx, $input, &argp, $descriptor,  0 , SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
  if (!argp) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
  $1 = ($ltype)(argp);
}


/* Rvalue reference */
%typemap(in, noblock=1) SWIGTYPE && (void *argp = 0, int res = 0) {
  res = SwigScilabPtrToObject(pvApiCtx, $input, &argp, $descriptor,  0 , SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
  if (!argp) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
  $1 = ($ltype)(argp);
}
%typemap(freearg) SWIGTYPE && "";















%typemap(in,noblock=1) const SWIGTYPE && (void *argp, int res = 0) {
  res = SwigScilabPtrToObject(pvApiCtx, $input, &argp, $descriptor,  0 , SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
  if (!argp) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
  $1 = ($ltype)(argp);
}


/* By value */















%typemap(in) SWIGTYPE (void *argp, int res = 0) {
  res = SwigScilabPtrToObject(pvApiCtx, $input, &argp, $&descriptor,  0 , SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }  
  if (!argp) { 
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  } else {
    $1 = *(($&ltype)(argp));
  }
}



/* -----------------------------------------------------------------------------
 * --- Output arguments --- 
 * ----------------------------------------------------------------------------- */

/* Pointers, references */
%typemap(out,noblock=1) SWIGTYPE *, SWIGTYPE &, SWIGTYPE &&, SWIGTYPE[] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), SWIG_as_voidptr($1), $descriptor, $owner |  0 , NULL)))) return SWIG_ERROR;
}

%typemap(out, noblock=1) SWIGTYPE *const& {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), SWIG_as_voidptr(*$1), $*descriptor, $owner |  0 , NULL)))) return SWIG_ERROR;
}

/* Return by value */
%typemap(out, noblock=1) SWIGTYPE {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (new $ltype((const $ltype&)($1))), $&descriptor, SWIG_POINTER_OWN |  0 , NULL)))) return SWIG_ERROR;
}

/* -----------------------------------------------------------------------------
 * --- Variable input --- 
 * ----------------------------------------------------------------------------- */

/* memberin/globalin/varin, for fix arrays. */

%typemap(memberin) SWIGTYPE [ANY] {
  if ($input) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) *($1_basetype *)&$1[ii] = *(($1_basetype *)$input + ii);
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}

%typemap(globalin) SWIGTYPE [ANY] {
  if ($input) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) *($1_basetype *)&$1[ii] = *(($1_basetype *)$input + ii);
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}

%typemap(varin) SWIGTYPE [ANY] {
  $basetype *inp = 0;
  int res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&inp), $descriptor,  0 , SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  } else if (inp) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) *($1_basetype *)&$1[ii] = *(($1_basetype *)inp + ii);
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}


/* memberin/globalin/varin, for fix double arrays. */

%typemap(memberin) SWIGTYPE [ANY][ANY] {
  if ($input) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) {
      if ($input[ii]) {
	size_t jj = 0;
	for (; jj < (size_t)$1_dim1; ++jj) $1[ii][jj] = $input[ii][jj];
      } else {
	SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
      }
    }
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}

%typemap(globalin) SWIGTYPE [ANY][ANY] {
  if ($input) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) {
      if ($input[ii]) {
	size_t jj = 0;
	for (; jj < (size_t)$1_dim1; ++jj) $1[ii][jj] = $input[ii][jj];
      } else {
	SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
      }
    }
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}

%typemap(varin) SWIGTYPE [ANY][ANY] {
  $basetype (*inp)[$1_dim1] = 0;
  int res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&inp), $descriptor,  0 , SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  } else if (inp) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) {
      if (inp[ii]) {
	size_t jj = 0;
	for (; jj < (size_t)$1_dim1; ++jj) $1[ii][jj] = inp[ii][jj];
      } else {
	SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
      }
    }
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}

/* Pointers, references, and variable size arrays */

%typemap(varin,warning=    "454:Setting a pointer/reference variable may leak memory." ) SWIGTYPE * {
  void *argp = 0;
  int res = SwigScilabPtrToObject(pvApiCtx, $input, &argp, $descriptor,  0 , SWIG_Scilab_GetFuncName());  
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  $1 = ($ltype)(argp);
}

%typemap(varin,noblock=1,warning="462:Unable to set dimensionless array variable") SWIGTYPE []
{
  SWIG_exception_fail(SWIG_ArgError(SWIG_AttributeError), "in variable '""read-only $name""' of type '""$type""'");
}

%typemap(varin,warning=    "454:Setting a pointer/reference variable may leak memory." ) SWIGTYPE & {
  void *argp = 0;
  int res = SwigScilabPtrToObject(pvApiCtx, $input, &argp, $descriptor,  0 , SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  if (!argp) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
  $1 = *(($ltype)(argp));
}

%typemap(varin,warning=    "454:Setting a pointer/reference variable may leak memory." ) SWIGTYPE && {
  void *argp = 0;
  int res = SwigScilabPtrToObject(pvApiCtx, $input, &argp, $descriptor,  0 , SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  if (!argp) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
  $1 = *(($ltype)(argp));
}


















%typemap(varin) SWIGTYPE {
  void *argp = 0;
  int res = SwigScilabPtrToObject(pvApiCtx, $input, &argp, $&descriptor,  0 , SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  if (!argp) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  } else {
    $1 = *(($&type)(argp));
  }
}


/* -----------------------------------------------------------------------------
 * --- Variable output --- 
 * ----------------------------------------------------------------------------- */

/* Pointers and arrays */
%typemap(varout, noblock=1) SWIGTYPE * {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), SWIG_as_voidptr($1), $descriptor,  0 , NULL)))) return SWIG_ERROR;
}

%typemap(varout, noblock=1) SWIGTYPE [] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), SWIG_as_voidptr($1), $descriptor,  0 , NULL)))) return SWIG_ERROR;
}

/* References */
%typemap(varout, noblock=1) SWIGTYPE & {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), SWIG_as_voidptr(&$1), $descriptor,  0 , NULL)))) return SWIG_ERROR;
}

%typemap(varout, noblock=1) SWIGTYPE && {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), SWIG_as_voidptr(&$1), $descriptor,  0 , NULL)))) return SWIG_ERROR;
}

/* Value */
%typemap(varout, noblock=1) SWIGTYPE {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), SWIG_as_voidptr(&$1), $&descriptor,  0 , NULL)))) return SWIG_ERROR;
}

/* ------------------------------------------------------------
 * --- Typechecking rules ---
 * ------------------------------------------------------------ */

%typemap(typecheck,precedence=      0     ,noblock=1) SWIGTYPE * {
  void *vptr = 0;
  int res = SwigScilabPtrToObject(pvApiCtx, $input, &vptr, $descriptor, 0, SWIG_Scilab_GetFuncName());
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,precedence=      0     ,noblock=1) SWIGTYPE *const& {
  void *vptr = 0;
  int res = SwigScilabPtrToObject(pvApiCtx, $input, &vptr, $*descriptor, 0, SWIG_Scilab_GetFuncName());
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,precedence=      0     ,noblock=1) SWIGTYPE & {
  void *vptr = 0;
  int res = SwigScilabPtrToObject(pvApiCtx, $input, &vptr, $descriptor, 0, SWIG_Scilab_GetFuncName());
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,precedence=      0     ,noblock=1) SWIGTYPE && {
  void *vptr = 0;
  int res = SwigScilabPtrToObject(pvApiCtx, $input, &vptr, $descriptor, 0, SWIG_Scilab_GetFuncName());
  $1 = SWIG_CheckState(res);
}

















%typemap(typecheck,precedence=      0     ,noblock=1) const SWIGTYPE & {
  void *vptr = 0;
  int res = SwigScilabPtrToObject(pvApiCtx, $input, &vptr, $descriptor, 0, SWIG_Scilab_GetFuncName());
  $1 = SWIG_CheckState(res);
}
%typemap(typecheck,precedence=      0     ,noblock=1) const SWIGTYPE && {
  void *vptr = 0;
  int res = SwigScilabPtrToObject(pvApiCtx, $input, &vptr, $descriptor, 0, SWIG_Scilab_GetFuncName());
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,precedence=      0     ,noblock=1) SWIGTYPE {
  void *vptr = 0;
  int res = SwigScilabPtrToObject(pvApiCtx, $input, &vptr, $&descriptor, 0, SWIG_Scilab_GetFuncName());
  $1 = SWIG_CheckState(res);
}


/* -----------------------------------------------------------------------------
 * --- Director typemaps --- *  
 * ----------------------------------------------------------------------------- */



























































































/* ------------------------------------------------------------
 * --- Constants ---
 * ------------------------------------------------------------ */

%typemap(constcode,noblock=1) SWIGTYPE *, SWIGTYPE &, SWIGTYPE &&, SWIGTYPE [] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), SWIG_as_voidptr($value), $descriptor,  0 , NULL)))) return SWIG_ERROR;
}

%typemap(constcode,noblock=1) SWIGTYPE {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), SWIG_as_voidptr(&$value), $&descriptor,  0 , NULL)))) return SWIG_ERROR;
}

/* ------------------------------------------------------------
 * --- Exception handling ---
 * ------------------------------------------------------------ */

%typemap(throws,noblock=1) SWIGTYPE {
  SWIG_Scilab_Raise(SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (new $ltype((const $ltype&)($1))), $&descriptor, SWIG_POINTER_OWN, NULL), "$type", $&descriptor);
}

%typemap(throws,noblock=1) SWIGTYPE * {
  SWIG_Scilab_Raise(SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), SWIG_as_voidptr($1), $descriptor, 0, NULL), "$type", $descriptor);
}

%typemap(throws,noblock=1) SWIGTYPE [ANY] {
  SWIG_Scilab_Raise(SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), SWIG_as_voidptr($1), $descriptor, 0, NULL), "$type", $descriptor);
}

%typemap(throws,noblock=1) SWIGTYPE & {
  SWIG_Scilab_Raise(SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), SWIG_as_voidptr(&$1), $descriptor, 0, NULL), "$type", $descriptor);
}

%typemap(throws,noblock=1) SWIGTYPE && {
  SWIG_Scilab_Raise(SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), SWIG_as_voidptr(&$1), $descriptor, 0, NULL), "$type", $descriptor);
}

%typemap(throws,noblock=1) (...) {
  SWIG_exception_fail(SWIG_RuntimeError,"unknown exception");
}

/* ------------------------------------------------------------
 * --- CLASS::* typemaps --- 
 * ------------------------------------------------------------ */

%typemap(in) SWIGTYPE (CLASS::*) {  
  int res = SWIG_Scilab_ConvertPacked(pvApiCtx, $input, SWIG_as_voidptr(&$1), sizeof($type), $descriptor, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
}

%typemap(out,noblock=1) SWIGTYPE (CLASS::*) {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_Scilab_NewMemberObj(pvApiCtx, $result, SWIG_as_voidptr(&$1), sizeof($type), $descriptor)))) return SWIG_ERROR;
}

%typemap(varin) SWIGTYPE (CLASS::*) {
  int res = SWIG_Scilab_ConvertPacked(pvApiCtx, $input, SWIG_as_voidptr(&$1), sizeof($type), $descriptor, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'"); 
  }
}

%typemap(varout,noblock=1) SWIGTYPE (CLASS::*) {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_Scilab_NewMemberObj(pvApiCtx, $result, SWIG_as_voidptr(&$1), sizeof($type), $descriptor)))) return SWIG_ERROR;
}

%typemap(constcode,noblock=1) SWIGTYPE (CLASS::*) {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_Scilab_NewMemberObj(pvApiCtx, $result, SWIG_as_voidptr(&$value), sizeof($type), $descriptor)))) return SWIG_ERROR;
}



















%apply SWIGTYPE (CLASS::*) { SWIGTYPE (CLASS::*const) }
%apply SWIGTYPE & { SWIGTYPE (CLASS::*const&) }

/* ------------------------------------------------------------
 * --- function ptr typemaps --- 
 * ------------------------------------------------------------ */

/*
  ISO C++ doesn't allow direct casting of a function ptr to a object
  ptr. So, maybe the ptr sizes are not the same, and we need to take
  some providences.
 */
%typemap(in) SWIGTYPE ((*)(ANY)) {
  int res = SwigScilabPtrToObject(pvApiCtx, $input, (void**)(&$1), $descriptor, 0, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
}

 %typemap(typecheck, precedence=      0     ,noblock=1)  SWIGTYPE ((*)(ANY)) {
  void *ptr = 0;
  int res = SwigScilabPtrToObject(pvApiCtx, $input, &ptr, $descriptor, 0, SWIG_Scilab_GetFuncName());
  $1 = SWIG_CheckState(res);
}


%typemap(out, noblock=1) SWIGTYPE ((*)(ANY)) {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void *)($1), $descriptor, 0, NULL)))) return SWIG_ERROR;
}

%typemap(varin) SWIGTYPE ((*)(ANY)) {
  int res = SwigScilabPtrToObject(pvApiCtx, $input, (void**)(&$1), $descriptor, 0, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'"); 
  }
}

%typemap(varout,noblock=1) SWIGTYPE ((*)(ANY)) {  
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void *)($1), $descriptor, 0, NULL)))) return SWIG_ERROR;
}

%typemap(constcode, noblock=1) SWIGTYPE ((*)(ANY)){
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void *)$value, $descriptor, 0, NULL)))) return SWIG_ERROR;
}
%typemap(constcode) SWIGTYPE ((* const)(ANY)) = SWIGTYPE ((*)(ANY));



















%apply SWIGTYPE * { SWIGTYPE *const }

/* ------------------------------------------------------------
 * --- Special typemaps ---
 * ------------------------------------------------------------ */

/* DISOWN typemap */

%typemap(in, noblock=1) SWIGTYPE *DISOWN (int res = 0) {
  res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, SWIG_POINTER_DISOWN |  0 , SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
}

%typemap(varin) SWIGTYPE *DISOWN {
  void *temp = 0;
  int res = SwigScilabPtrToObject(pvApiCtx, $input, &temp, $descriptor, SWIG_POINTER_DISOWN |  0 , SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  $1 = ($ltype) temp;
}

/* DYNAMIC typemap */

%typemap(out,noblock=1) SWIGTYPE *DYNAMIC, SWIGTYPE &DYNAMIC {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), SWIG_as_voidptr($1), SWIG_TypeDynamicCast($descriptor, SWIG_as_voidptrptr(&$1)), $owner |  0 , NULL)))) return SWIG_ERROR;
}

/* INSTANCE typemap */

%typemap(out,noblock=1) SWIGTYPE INSTANCE {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_NewInstanceObj((new $1_ltype((const $1_ltype&)($1))), $&1_descriptor, SWIG_POINTER_OWN | 0 )))) return SWIG_ERROR;
}

%typemap(out,noblock=1) SWIGTYPE *INSTANCE, SWIGTYPE &INSTANCE, SWIGTYPE INSTANCE[] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_NewInstanceObj(SWIG_as_voidptr($1), $1_descriptor, $owner | 0 )))) return SWIG_ERROR;
}

%typemap(varout,noblock=1) SWIGTYPE *INSTANCE, SWIGTYPE INSTANCE[] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_NewInstanceObj(SWIG_as_voidptr($1), $1_descriptor, 0 )))) return SWIG_ERROR;
}

%typemap(varout,noblock=1) SWIGTYPE &INSTANCE {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_NewInstanceObj(SWIG_as_voidptr($1), $1_descriptor, 0 )))) return SWIG_ERROR;
}

%typemap(varout,noblock=1) SWIGTYPE INSTANCE {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_NewInstanceObj(SWIG_as_voidptr(&$1), $&1_descriptor, 0 )))) return SWIG_ERROR;
}

%endoffile
%includefile "/usr/local/share/swig/4.0.0/typemaps/void.swg" %beginfile
/* ------------------------------------------------------------
 * Void * -  Accepts any kind of pointer
 * ------------------------------------------------------------ */

/* in */

%typemap(in,noblock=1) void * (int res) {
  res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), 0, $disown, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
}
%typemap(freearg) void * "";

%typemap(in,noblock=1) void * const& ($*ltype temp = 0, int res) {
  res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&temp), 0, $disown, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "Stype""'"); 
  }
  $1 =  &temp;
}
%typemap(freearg) void * const& "";


/* out */




%typemap(out,noblock=1) void {}


/* varin */

%typemap(varin) void * {
  void *temp = 0;
  int res = SwigScilabPtrToObject(pvApiCtx, $input, &temp, 0, SWIG_POINTER_DISOWN, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  $1 = ($1_ltype) temp;
}

/* typecheck */

 %typemap(typecheck, precedence=      10    ,noblock=1)  void *
{
  void *ptr = 0;
  int res = SwigScilabPtrToObject(pvApiCtx, $input, &ptr, 0, 0, SWIG_Scilab_GetFuncName());
  $1 = SWIG_CheckState(res);
}

































%endoffile
%includefile "/usr/local/share/swig/4.0.0/typemaps/swigobject.swg" %beginfile
/* ------------------------------------------------------------
 * Language Object *  - Just pass straight through unmodified
 * ------------------------------------------------------------ */

%typemap(in)   int "$1 = $input;";

%typemap(in,noblock=1)   int const & ($*ltype temp)
{
  temp = ($*ltype)($input);
  $1 = &temp;
}

%typemap(out,noblock=1) int {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, $1))) return SWIG_ERROR;
}

%typemap(out,noblock=1)  int const & {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, *$1))) return SWIG_ERROR;
}

 %typemap(typecheck, precedence=       5000    )  int "$1 = ($input != 0);";

%typemap(throws,noblock=1) int {
  SWIG_Scilab_Raise($1, "$type", 0);
}

%typemap(constcode,noblock=1) int {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, $value))) return SWIG_ERROR;
}








%endoffile
%includefile "/usr/local/share/swig/4.0.0/typemaps/valtypes.swg" %beginfile
/*---------------------------------------------------------------------
 * Value typemaps (Type, const Type&) for value types, such as
 * fundamental types (int, double), that define the AsVal/From
 * methods.
 *
 * To apply them, just use one of the following macros:
 *
 *   %typemaps_from(FromMeth, FromFrag, Type)
 *   %typemaps_asval(CheckCode, AsValMeth, AsValFrag, Type)
 *   %typemaps_asvalfrom(CheckCode, AsValMeth, FromMeth, AsValFrag, FromFrag, Type)
 *
 * or the simpler and normalize form:
 *
 *   %typemaps_asvalfromn(CheckCode, Type)
 *
 * Also, you can use the individual typemap definitions:
 *
 *    %value_in_typemap(asval_meth,frag,Type)
 *    %value_varin_typemap(asval_meth,frag,Type)
 *    %value_typecheck_typemap(checkcode,asval_meth,frag,Type)
 *    %value_directorout_typemap(asval_meth,frag,Type)
 *
 *    %value_out_typemap(from_meth,frag,Type)
 *    %value_varout_typemap(from_meth,frag,Type)
 *    %value_constcode_typemap(from_meth,frag,Type)
 *    %value_directorin_typemap(from_meth,frag,Type)
 *    %value_throws_typemap(from_meth,frag,Type)
 *
 *---------------------------------------------------------------------*/

/* in */





















/* out */










/* varin */












/* varout */







/* constant installation code */

































































/* throws */







/* typecheck */








/*---------------------------------------------------------------------
 * typemap definition for types with AsVal methods
 *---------------------------------------------------------------------*/









/*---------------------------------------------------------------------
 * typemap definition for types with from method
 *---------------------------------------------------------------------*/










/*---------------------------------------------------------------------
 * typemap definition for types with alval/from method
 *---------------------------------------------------------------------*/









/*---------------------------------------------------------------------
 * typemap definition for types  with for 'normalized' asval/from methods
 *---------------------------------------------------------------------*/








%endoffile
%includefile "/usr/local/share/swig/4.0.0/typemaps/ptrtypes.swg" %beginfile
/* -----------------------------------------------------------------------------
 * ptrtypes.swg
 *
 * Value typemaps (Type, const Type&) for "Ptr" types, such as swig
 * wrapped classes, that define the AsPtr/From methods
 *
 * To apply them, just use one of the following macros:
 *
 *    %typemaps_asptr(CheckCode, AsPtrMeth, AsPtrFrag, Type)
 *    %typemaps_asptrfrom(CheckCode, AsPtrMeth, FromMeth, AsPtrFrag, FromFrag, Type)
 *
 * or the simpler and normalize form:
 *
 *    %typemaps_asptrfromn(CheckCode, Type)
 *
 * Also, you can use the individual typemap definitions:
 *
 *    %ptr_in_typemap(asptr_meth,frag,Type)
 *    %ptr_varin_typemap(asptr_meth,frag,Type)
 *    %ptr_typecheck_typemap(check,asptr_meth,frag,Type)
 *    %ptr_directorout_typemap(asptr_meth,frag,Type)
 * ----------------------------------------------------------------------------- */



/* in */
























/* varin */

























































































/* typecheck */














/*---------------------------------------------------------------------
 * typemap definition for types with asptr method
 *---------------------------------------------------------------------*/



























/*---------------------------------------------------------------------
 * typemap definition for types with asptr/from methods
 *---------------------------------------------------------------------*/








/*---------------------------------------------------------------------
 * typemap definition for types  with for 'normalized' asptr/from methods
 *---------------------------------------------------------------------*/









%endoffile
%includefile "/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg" %beginfile
/*  ------------------------------------------------------------
 *
 * Define the IN/OUTPUT typemaps assuming the output parameters are
 * returned in a list, i.e., they are not directly modified.
 *
 * The user should provide the %append_output(result, obj) method,
 * via a macro, which append a particular object to the result.
 *
 *
 * In Tcl, for example, the file is used as:
 *
 *   #define %append_output(obj) Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),obj);
 *   %include <typemaps/inoutlist.swg>
 *
 * while in Python it is used as:
 *
 *   #define %append_output(obj) $result = SWIG_Python_AppendResult($result, obj)
 *   %include <typemaps/inoutlist.swg>
 *
 * where the method SWIG_Python_AppendResult is defined inside the
 * %append_output fragment.
 *
 * If you forget to define %append_output, this file will generate
 * an error.
 *
 * ------------------------------------------------------------ */


//
// Uncomment the following definition if you don't want the in/out
// typemaps by default, ie, you prefer to use typemaps.i.
//
//#define SWIG_INOUT_NODEF

//
// Use the following definition to enable the INPUT parameters to
// accept both 'by value' and 'pointer' objects.
//


// ------------------------------------------------------------------------
// Pointer handling
//
// These mappings provide support for input/output arguments and common
// uses for C/C++ pointers.
// ------------------------------------------------------------------------

// INPUT typemaps.
// These remap a C pointer to be an "INPUT" value which is passed by value
// instead of reference.

/* 
The following methods can be applied to turn a pointer into a simple
"input" value.  That is, instead of passing a pointer to an object,
you would use a real value instead.
         
To use these, suppose you had a C function like this :

        double fadd(double *a, double *b) {
               return *a+*b;
        }

You could wrap it with SWIG as follows :

        double fadd(double *INPUT, double *INPUT);

or you can use the %apply directive :

        %apply double *INPUT { double *a, double *b };
        double fadd(double *a, double *b);

*/







































































// OUTPUT typemaps.   These typemaps are used for parameters that
// are output only.   The output value is appended to the result as
// a list element.

/* 
The following methods can be applied to turn a pointer into an "output"
value.  When calling a function, no input value would be given for
a parameter, but an output value would be returned.  In the case of
multiple output values, they are returned in the form of a list.

         
For example, suppose you were trying to wrap the modf() function in the
C math library which splits x into integral and fractional parts (and
returns the integer part in one of its parameters):

        double modf(double x, double *ip);

You could wrap it with SWIG as follows :

        double modf(double x, double *OUTPUT);

or you can use the %apply directive :

        %apply double *OUTPUT { double *ip };
        double modf(double x, double *ip);

The output of the function would be a list containing both output
values.

*/


















// INOUT
// Mappings for an argument that is both an input and output
// parameter

/*
The following methods can be applied to make a function parameter both
an input and output value.  This combines the behavior of both the
"INPUT" and "OUTPUT" methods described earlier.  Output values are
returned in the form of a list.  
         
For example, suppose you were trying to wrap the following function :

        void neg(double *x) {
             *x = -(*x);
        }

You could wrap it with SWIG as follows :

        void neg(double *INOUT);

or you can use the %apply directive :

        %apply double *INOUT { double *x };
        void neg(double *x);

Unlike C, this mapping does not directly modify the input value.
Rather, the modified input value shows up as the return value of the
function.  Thus, to apply this function to a variable you might do
this :

       x = neg(x)

Note : previous versions of SWIG used the symbol 'BOTH' to mark
input/output arguments.   This is still supported, but will be slowly
phased out in future releases.

*/















































/*----------------------------------------------------------------------
  Front ends.
  
  use the following macros to define your own IN/OUTPUT/INOUT typemaps
  
  ------------------------------------------------------------------------*/















%endoffile
%includefile "/usr/local/share/swig/4.0.0/typemaps/primtypes.swg" %beginfile
/* ------------------------------------------------------------
 * Primitive type fragments and macros 
 * ------------------------------------------------------------ */

/*
  This file provide fragments and macros for the C/C++ primitive types. 

  The file defines default fragments for the following types:

    bool
    signed char
    unsigned char
    signed wchar_t     // in C++
    unsigned wchar_t   // in C++
    short
    unsigned short
    int
    unsigned int
    float
    size_t
    ptrdiff_t

  which can always be redefined in the swig target language if needed.
  
  The fragments for the following types, however, always need to be
  defined in the target language:

    long
    unsigned long
    long long
    unsigned long long
    double
 
  If they are not provided, an #error directive will appear in the
  wrapped code.

  --------------------------------------------------------------------
  
  This file provides the macro

    %typemaps_primitive(CheckCode, Type)

  which generates the typemaps for a primitive type with a given
  checkcode. It is assumed that the primitive type is 'normalized' and
  the corresponding SWIG_AsVal(Type) and SWIG_From(Type) methods are
  provided via fragments.
  
   
  The following auxiliary macros (explained with bash pseudo code) are
  also defined:

    %apply_ctypes(Macro)
      for i in C Type
      do
        Macro($i)
      done

    %apply_cpptypes(Macro)
      for i in C++ Type
      do
        Macro($i)
      done

    %apply_ctypes_2(Macro2)
       for i in C Type
       do
         for j in C Type
         do
            Macro_2($i, $j)
         done
       done

    %apply_cpptypes_2(Macro2)
       for i in C++ Type
       do
         for j in C++ Type
         do
            Macro_2($i, $j)
         done
       done

    %apply_checkctypes(Macro2)
       for i in Check Type
       do
         Macro2(%checkcode($i), $i)
       done

*/


/* ------------------------------------------------------------
 * Primitive type fragments 
 * ------------------------------------------------------------ */
/* boolean */

%fragment("SWIG_" "From" "_" {bool},"header",fragment="SWIG_" "From" "_" {long}) {
SWIGINTERN int
SWIG_From_bool  (bool value)
{    
  return SWIG_From_long  (value ? 1 : 0);
}
}

%fragment("SWIG_" "AsVal" "_" {bool},"header",fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_AsVal_bool (int obj, bool *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res)) {    
    if (val) *val = v ? true : false;
    return res;
  }  
  return SWIG_TypeError;
}
}

/* signed/unsigned char */

/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,255,%numeric_slong@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,214,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {signed char},"header",
	  fragment="SWIG_" "From" "_" {long}) {
SWIGINTERNINLINE int
SWIG_SciDouble_FromSignedChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), signed char value)
{    
  return SWIG_From_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,225,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {signed char},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_SciDoubleOrInt8_AsSignedChar(pvApiCtx, int obj, signed char *val, SWIG_Scilab_GetFuncName())
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < SCHAR_MIN || v > SCHAR_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (signed char)(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,262,%numeric_ulong@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,214,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {unsigned char},"header",
	  fragment="SWIG_" "From" "_" {unsigned long}) {
SWIGINTERNINLINE int
SWIG_SciDouble_FromUnsignedChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), unsigned char value)
{    
  return SWIG_UnsignedInt_FromUnsignedLong(pvApiCtx, SWIG_Scilab_GetOutputPosition(), value, SWIG_Scilab_GetFuncName());
}
}
/*@SWIG@*/
 /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,225,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {unsigned char},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {unsigned long}) {
SWIGINTERN int
SWIG_SciDoubleOrUint8_AsUnsignedChar(pvApiCtx, int obj, unsigned char *val, SWIG_Scilab_GetFuncName())
{
  unsigned long v;
  int res = SWIG_UnsignedInt_AsUnsignedLong(pvApiCtx, obj, &v, SWIG_Scilab_GetFuncName());
  if (SWIG_IsOK(res)) {
    if ((v > UCHAR_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (unsigned char)(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/

/* short/unsigned short */

/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,255,%numeric_slong@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,214,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {short},"header",
	  fragment="SWIG_" "From" "_" {long}) {
SWIGINTERNINLINE int
SWIG_SciDouble_FromShort(pvApiCtx, SWIG_Scilab_GetOutputPosition(), short value, SWIG_Scilab_GetFuncName())
{    
  return SWIG_From_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,225,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {short},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_SciDoubleOrInt16_AsShort(pvApiCtx, int obj, short *val, SWIG_Scilab_GetFuncName())
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < SHRT_MIN || v > SHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (short)(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,262,%numeric_ulong@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,214,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {unsigned short},"header",
	  fragment="SWIG_" "From" "_" {unsigned long}) {
SWIGINTERNINLINE int
SWIG_From_unsigned_SS_short  (unsigned short value)
{    
  return SWIG_UnsignedInt_FromUnsignedLong(pvApiCtx, SWIG_Scilab_GetOutputPosition(), value, SWIG_Scilab_GetFuncName());
}
}
/*@SWIG@*/
 /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,225,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {unsigned short},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {unsigned long}) {
SWIGINTERN int
SWIG_AsVal_unsigned_SS_short (int obj, unsigned short *val)
{
  unsigned long v;
  int res = SWIG_UnsignedInt_AsUnsignedLong(pvApiCtx, obj, &v, SWIG_Scilab_GetFuncName());
  if (SWIG_IsOK(res)) {
    if ((v > USHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (unsigned short)(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/

/* int/unsigned int */

/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,255,%numeric_slong@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,214,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {int},"header",
	  fragment="SWIG_" "From" "_" {long}) {
SWIGINTERNINLINE int
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,225,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {int},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_AsVal_int (int obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (int)(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,262,%numeric_ulong@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,214,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {unsigned int},"header",
	  fragment="SWIG_" "From" "_" {unsigned long}) {
SWIGINTERNINLINE int
SWIG_From_unsigned_SS_int  (unsigned int value)
{    
  return SWIG_UnsignedInt_FromUnsignedLong(pvApiCtx, SWIG_Scilab_GetOutputPosition(), value, SWIG_Scilab_GetFuncName());
}
}
/*@SWIG@*/
 /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,225,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {unsigned int},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {unsigned long}) {
SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (int obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_UnsignedInt_AsUnsignedLong(pvApiCtx, obj, &v, SWIG_Scilab_GetFuncName());
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (unsigned int)(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/

/* signed/unsigned wchar_t */


/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,255,%numeric_slong@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,214,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {signed wchar_t},"header",
	  fragment="SWIG_" "From" "_" {long}) {
SWIGINTERNINLINE int
SWIG_From_signed_SS_wchar_t  (signed wchar_t value)
{    
  return SWIG_From_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,225,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {signed wchar_t},"header",
	  fragment="<wchar.h>",
	  fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_AsVal_signed_SS_wchar_t (int obj, signed wchar_t *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < WCHAR_MIN || v > WCHAR_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (signed wchar_t)(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,262,%numeric_ulong@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,214,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {unsigned wchar_t},"header",
	  fragment="SWIG_" "From" "_" {unsigned long}) {
SWIGINTERNINLINE int
SWIG_From_unsigned_SS_wchar_t  (unsigned wchar_t value)
{    
  return SWIG_UnsignedInt_FromUnsignedLong(pvApiCtx, SWIG_Scilab_GetOutputPosition(), value, SWIG_Scilab_GetFuncName());
}
}
/*@SWIG@*/
 /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,225,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {unsigned wchar_t},"header",
	  fragment="<wchar.h>",
	  fragment="SWIG_" "AsVal" "_" {unsigned long}) {
SWIGINTERN int
SWIG_AsVal_unsigned_SS_wchar_t (int obj, unsigned wchar_t *val)
{
  unsigned long v;
  int res = SWIG_UnsignedInt_AsUnsignedLong(pvApiCtx, obj, &v, SWIG_Scilab_GetFuncName());
  if (SWIG_IsOK(res)) {
    if ((v > UWCHAR_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (unsigned wchar_t)(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/


/* float */

/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,277,%numeric_float@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,214,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {float},"header",
	  fragment="SWIG_" "From" "_" {double}) {
SWIGINTERNINLINE int
SWIG_From_float  (float value)
{    
  return SWIG_From_double  (value);
}
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,225,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {float},"header",
	  fragment="SWIG_Float_Overflow_Check",
	  fragment="SWIG_" "AsVal" "_" {double}) {
SWIGINTERN int
SWIG_AsVal_float (int obj, float *val)
{
  double v;
  int res = SWIG_AsVal_double (obj, &v);
  if (SWIG_IsOK(res)) {
    if (SWIG_Float_Overflow_Check(v)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (float)(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/

/* long/unsigned long */

/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,291,%ensure_type_fragments@*/
%fragment("SWIG_" "From" "_" {long},"header") {
#error "SWIG language implementation must provide a SWIG_From_frag(long) fragment"
}
%fragment("SWIG_" "AsVal" "_" {long},"header") {
#error "SWIG language implementation must provide a SWIG_AsVal_frag(long) fragment"
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,291,%ensure_type_fragments@*/
%fragment("SWIG_" "From" "_" {unsigned long},"header") {
#error "SWIG language implementation must provide a SWIG_From_frag(unsigned long) fragment"
}
%fragment("SWIG_" "AsVal" "_" {unsigned long},"header") {
#error "SWIG language implementation must provide a SWIG_AsVal_frag(unsigned long) fragment"
}
/*@SWIG@*/

/* long long/unsigned long long */

%fragment("SWIG_LongLongAvailable","header", fragment="<limits.h>") %{
#if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
#  define SWIG_LONG_LONG_AVAILABLE
#endif
%}

/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,291,%ensure_type_fragments@*/
%fragment("SWIG_" "From" "_" {long long},"header") {
#error "SWIG language implementation must provide a SWIG_From_frag(long long) fragment"
}
%fragment("SWIG_" "AsVal" "_" {long long},"header") {
#error "SWIG language implementation must provide a SWIG_AsVal_frag(long long) fragment"
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,291,%ensure_type_fragments@*/
%fragment("SWIG_" "From" "_" {unsigned long long},"header") {
#error "SWIG language implementation must provide a SWIG_From_frag(unsigned long long) fragment"
}
%fragment("SWIG_" "AsVal" "_" {unsigned long long},"header") {
#error "SWIG language implementation must provide a SWIG_AsVal_frag(unsigned long long) fragment"
}
/*@SWIG@*/

/* double */

/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,291,%ensure_type_fragments@*/
%fragment("SWIG_" "From" "_" {double},"header") {
#error "SWIG language implementation must provide a SWIG_From_frag(double) fragment"
}
%fragment("SWIG_" "AsVal" "_" {double},"header") {
#error "SWIG language implementation must provide a SWIG_AsVal_frag(double) fragment"
}
/*@SWIG@*/

/* size_t */

%fragment("SWIG_" "From" "_" {size_t},"header",fragment="SWIG_" "From" "_" {unsigned long},fragment="SWIG_" "From" "_" {unsigned long long}) {
SWIGINTERNINLINE int
SWIG_From_size_t  (size_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    return SWIG_From_unsigned_SS_long  ((unsigned long)(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(size_t) <= sizeof(unsigned long long) */
    return SWIG_From_unsigned_SS_long_SS_long  ((unsigned long long)(value));
  }
#endif
}
}

%fragment("SWIG_" "AsVal" "_" {size_t},"header",fragment="SWIG_" "AsVal" "_" {unsigned long},fragment="SWIG_" "AsVal" "_" {unsigned long long}) {
SWIGINTERNINLINE int
SWIG_AsVal_size_t (int obj, size_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = (size_t)(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(size_t) <= sizeof(unsigned long long)) {
    unsigned long long v;
    res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = (size_t)(v);
  }
#endif
  return res;
}
}

/* ptrdiff_t */

%fragment("SWIG_" "From" "_" {ptrdiff_t},"header",fragment="SWIG_" "From" "_" {long},fragment="SWIG_" "From" "_" {long long}) {
SWIGINTERNINLINE int
SWIG_From_ptrdiff_t  (ptrdiff_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(ptrdiff_t) <= sizeof(long)) {
#endif
    return SWIG_From_long  ((long)(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(ptrdiff_t) <= sizeof(long long) */
    return SWIG_From_long_SS_long  ((long long)(value));
  }
#endif
}
}

%fragment("SWIG_" "AsVal" "_" {ptrdiff_t},"header",fragment="SWIG_" "AsVal" "_" {long},fragment="SWIG_" "AsVal" "_" {long long}) {
SWIGINTERNINLINE int
SWIG_AsVal_ptrdiff_t (int obj, ptrdiff_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(ptrdiff_t) <= sizeof(long)) {
#endif
    long v;
    res = SWIG_AsVal_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = (ptrdiff_t)(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(ptrdiff_t) <= sizeof(long long)) {
    long long v;
    res = SWIG_AsVal_long_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = (ptrdiff_t)(v);
  }
#endif
  return res;
}
}


%fragment("SWIG_CanCastAsInteger","header",
	  fragment="SWIG_" "AsVal" "_" {double},
	  fragment="<float.h>",
	  fragment="<math.h>") {
SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}
}

/* ------------------------------------------------------------
 * Generate the typemaps for primitive type 
 * ------------------------------------------------------------ */



/* ------------------------------------------------------------
 * Primitive Type Macros
 * ------------------------------------------------------------ */

/* useful macros to derive typemap declarations from primitive types */









/* Apply macro to the C-types */




















/* apply the Macro2(Type1, Type2) to all  C types  */



/* apply the Macro(Type) to all  C++ types  */










/* apply the Macro2(Type1, Type2) to all  C++ types  */


/* apply the Macro2(CheckCode,Type) to all  Checked Types */





















/* ------------------------------------------------------------
 * Generate the typemaps for all the primitive types with checkcode
 * ------------------------------------------------------------ */

/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/primtypes.swg,341,%apply_checkctypes@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool (bool val, int ecode = 0) {
    ecode = SWIG_AsVal_bool($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = ($ltype)(val);
  }
  %typemap(freearg) bool "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) const bool & ($*ltype temp, bool val, int ecode = 0) {  
    ecode = SWIG_AsVal_bool($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = ($*ltype)(val);
    $1 = &temp;
  }
  %typemap(freearg) const bool& "";
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {bool}) bool {
    bool val;
    int res = SWIG_AsVal_bool($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = ($ltype)(val);
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=15,fragment="SWIG_" "AsVal" "_" {bool}) bool, const bool& {
    int res = SWIG_AsVal_bool($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      bool val; 
      int ecode = SWIG_AsVal_bool($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      bool val;
      int ecode = SWIG_AsVal_bool($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") bool *INPUT, bool &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=15,fragment="SWIG_" "AsVal" "_" {bool}) bool *INPUT, bool &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_bool($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&ptr), $1_descriptor, 0, SWIG_Scilab_GetFuncName()))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool, const bool {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_bool((bool)($1))))) return SWIG_ERROR; 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {bool}) const bool& {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_bool((bool)(*$1))))) return SWIG_ERROR; 
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool, const bool&  {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_bool((bool)($1))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_bool((bool)($value))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool {
    SWIG_Scilab_Raise(SWIG_From_bool((bool)($1)), "$type", 0);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   bool *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   bool &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool *OUTPUT, bool &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_bool((*$1))))) return SWIG_ERROR;
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void*)($1), $1_descriptor, new_flags, NULL)))) return SWIG_ERROR;
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) bool *INOUT = bool *INPUT;
 %typemap(in) bool &INOUT = bool &INPUT;
 %typemap(typecheck) bool *INOUT = bool *INPUT;
 %typemap(typecheck) bool &INOUT = bool &INPUT;
 %typemap(argout) bool *INOUT = bool *OUTPUT;
 %typemap(argout) bool &INOUT = bool &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char (signed char val, int ecode = 0) {
    ecode = SWIG_SciDoubleOrInt8_AsSignedChar(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = ($ltype)(val);
  }
  %typemap(freearg) signed char "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) const signed char & ($*ltype temp, signed char val, int ecode = 0) {  
    ecode = SWIG_SciDoubleOrInt8_AsSignedChar(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = ($*ltype)(val);
    $1 = &temp;
  }
  %typemap(freearg) const signed char& "";
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {signed char}) signed char {
    signed char val;
    int res = SWIG_SciDoubleOrInt8_AsSignedChar(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = ($ltype)(val);
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=25,fragment="SWIG_" "AsVal" "_" {signed char}) signed char, const signed char& {
    int res = SWIG_SciDoubleOrInt8_AsSignedChar(pvApiCtx, $input, NULL, SWIG_Scilab_GetFuncName());
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      signed char val; 
      int ecode = SWIG_SciDoubleOrInt8_AsSignedChar(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      signed char val;
      int ecode = SWIG_SciDoubleOrInt8_AsSignedChar(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") signed char *INPUT, signed char &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=25,fragment="SWIG_" "AsVal" "_" {signed char}) signed char *INPUT, signed char &INPUT {
    void *ptr = 0;
    int res = SWIG_SciDoubleOrInt8_AsSignedChar(pvApiCtx, $input, 0, SWIG_Scilab_GetFuncName());
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&ptr), $1_descriptor, 0, SWIG_Scilab_GetFuncName()))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char, const signed char {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromSignedChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (signed char)($1))))) return SWIG_ERROR; 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {signed char}) const signed char& {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromSignedChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (signed char)(*$1))))) return SWIG_ERROR; 
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char, const signed char&  {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromSignedChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (signed char)($1))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromSignedChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (signed char)($value))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char {
    SWIG_Scilab_Raise(SWIG_SciDouble_FromSignedChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (signed char)($1)), "$type", 0);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   signed char *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   signed char &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char *OUTPUT, signed char &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromSignedChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (*$1))))) return SWIG_ERROR;
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void*)($1), $1_descriptor, new_flags, NULL)))) return SWIG_ERROR;
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) signed char *INOUT = signed char *INPUT;
 %typemap(in) signed char &INOUT = signed char &INPUT;
 %typemap(typecheck) signed char *INOUT = signed char *INPUT;
 %typemap(typecheck) signed char &INOUT = signed char &INPUT;
 %typemap(argout) signed char *INOUT = signed char *OUTPUT;
 %typemap(argout) signed char &INOUT = signed char &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char (unsigned char val, int ecode = 0) {
    ecode = SWIG_SciDoubleOrUint8_AsUnsignedChar(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = ($ltype)(val);
  }
  %typemap(freearg) unsigned char "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) const unsigned char & ($*ltype temp, unsigned char val, int ecode = 0) {  
    ecode = SWIG_SciDoubleOrUint8_AsUnsignedChar(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = ($*ltype)(val);
    $1 = &temp;
  }
  %typemap(freearg) const unsigned char& "";
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char {
    unsigned char val;
    int res = SWIG_SciDoubleOrUint8_AsUnsignedChar(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = ($ltype)(val);
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=20,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char, const unsigned char& {
    int res = SWIG_SciDoubleOrUint8_AsUnsignedChar(pvApiCtx, $input, NULL, SWIG_Scilab_GetFuncName());
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      unsigned char val; 
      int ecode = SWIG_SciDoubleOrUint8_AsUnsignedChar(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      unsigned char val;
      int ecode = SWIG_SciDoubleOrUint8_AsUnsignedChar(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") unsigned char *INPUT, unsigned char &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=20,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char *INPUT, unsigned char &INPUT {
    void *ptr = 0;
    int res = SWIG_SciDoubleOrUint8_AsUnsignedChar(pvApiCtx, $input, 0, SWIG_Scilab_GetFuncName());
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&ptr), $1_descriptor, 0, SWIG_Scilab_GetFuncName()))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char, const unsigned char {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromUnsignedChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (unsigned char)($1))))) return SWIG_ERROR; 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) const unsigned char& {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromUnsignedChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (unsigned char)(*$1))))) return SWIG_ERROR; 
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char, const unsigned char&  {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromUnsignedChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (unsigned char)($1))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromUnsignedChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (unsigned char)($value))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char {
    SWIG_Scilab_Raise(SWIG_SciDouble_FromUnsignedChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (unsigned char)($1)), "$type", 0);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   unsigned char *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   unsigned char &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char *OUTPUT, unsigned char &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromUnsignedChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (*$1))))) return SWIG_ERROR;
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void*)($1), $1_descriptor, new_flags, NULL)))) return SWIG_ERROR;
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) unsigned char *INOUT = unsigned char *INPUT;
 %typemap(in) unsigned char &INOUT = unsigned char &INPUT;
 %typemap(typecheck) unsigned char *INOUT = unsigned char *INPUT;
 %typemap(typecheck) unsigned char &INOUT = unsigned char &INPUT;
 %typemap(argout) unsigned char *INOUT = unsigned char *OUTPUT;
 %typemap(argout) unsigned char &INOUT = unsigned char &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short (short val, int ecode = 0) {
    ecode = SWIG_SciDoubleOrInt16_AsShort(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = ($ltype)(val);
  }
  %typemap(freearg) short "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) const short & ($*ltype temp, short val, int ecode = 0) {  
    ecode = SWIG_SciDoubleOrInt16_AsShort(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = ($*ltype)(val);
    $1 = &temp;
  }
  %typemap(freearg) const short& "";
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {short}) short {
    short val;
    int res = SWIG_SciDoubleOrInt16_AsShort(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = ($ltype)(val);
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=35,fragment="SWIG_" "AsVal" "_" {short}) short, const short& {
    int res = SWIG_SciDoubleOrInt16_AsShort(pvApiCtx, $input, NULL, SWIG_Scilab_GetFuncName());
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      short val; 
      int ecode = SWIG_SciDoubleOrInt16_AsShort(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      short val;
      int ecode = SWIG_SciDoubleOrInt16_AsShort(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") short *INPUT, short &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=35,fragment="SWIG_" "AsVal" "_" {short}) short *INPUT, short &INPUT {
    void *ptr = 0;
    int res = SWIG_SciDoubleOrInt16_AsShort(pvApiCtx, $input, 0, SWIG_Scilab_GetFuncName());
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&ptr), $1_descriptor, 0, SWIG_Scilab_GetFuncName()))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {short}) short, const short {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromShort(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (short)($1), SWIG_Scilab_GetFuncName())))) return SWIG_ERROR; 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {short}) const short& {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromShort(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (short)(*$1), SWIG_Scilab_GetFuncName())))) return SWIG_ERROR; 
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {short}) short, const short&  {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromShort(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (short)($1), SWIG_Scilab_GetFuncName())))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {short}) short {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromShort(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (short)($value), SWIG_Scilab_GetFuncName())))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {short}) short {
    SWIG_Scilab_Raise(SWIG_SciDouble_FromShort(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (short)($1), SWIG_Scilab_GetFuncName()), "$type", 0);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   short *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   short &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {short}) short *OUTPUT, short &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromShort(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (*$1), SWIG_Scilab_GetFuncName())))) return SWIG_ERROR;
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void*)($1), $1_descriptor, new_flags, NULL)))) return SWIG_ERROR;
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) short *INOUT = short *INPUT;
 %typemap(in) short &INOUT = short &INPUT;
 %typemap(typecheck) short *INOUT = short *INPUT;
 %typemap(typecheck) short &INOUT = short &INPUT;
 %typemap(argout) short *INOUT = short *OUTPUT;
 %typemap(argout) short &INOUT = short &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short (unsigned short val, int ecode = 0) {
    ecode = SWIG_AsVal_unsigned_SS_short($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = ($ltype)(val);
  }
  %typemap(freearg) unsigned short "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) const unsigned short & ($*ltype temp, unsigned short val, int ecode = 0) {  
    ecode = SWIG_AsVal_unsigned_SS_short($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = ($*ltype)(val);
    $1 = &temp;
  }
  %typemap(freearg) const unsigned short& "";
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short {
    unsigned short val;
    int res = SWIG_AsVal_unsigned_SS_short($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = ($ltype)(val);
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=30,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short, const unsigned short& {
    int res = SWIG_AsVal_unsigned_SS_short($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      unsigned short val; 
      int ecode = SWIG_AsVal_unsigned_SS_short($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      unsigned short val;
      int ecode = SWIG_AsVal_unsigned_SS_short($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") unsigned short *INPUT, unsigned short &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=30,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short *INPUT, unsigned short &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_unsigned_SS_short($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&ptr), $1_descriptor, 0, SWIG_Scilab_GetFuncName()))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short, const unsigned short {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_unsigned_SS_short((unsigned short)($1))))) return SWIG_ERROR; 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) const unsigned short& {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_unsigned_SS_short((unsigned short)(*$1))))) return SWIG_ERROR; 
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short, const unsigned short&  {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_unsigned_SS_short((unsigned short)($1))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_unsigned_SS_short((unsigned short)($value))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short {
    SWIG_Scilab_Raise(SWIG_From_unsigned_SS_short((unsigned short)($1)), "$type", 0);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   unsigned short *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   unsigned short &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short *OUTPUT, unsigned short &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_unsigned_SS_short((*$1))))) return SWIG_ERROR;
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void*)($1), $1_descriptor, new_flags, NULL)))) return SWIG_ERROR;
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) unsigned short *INOUT = unsigned short *INPUT;
 %typemap(in) unsigned short &INOUT = unsigned short &INPUT;
 %typemap(typecheck) unsigned short *INOUT = unsigned short *INPUT;
 %typemap(typecheck) unsigned short &INOUT = unsigned short &INPUT;
 %typemap(argout) unsigned short *INOUT = unsigned short *OUTPUT;
 %typemap(argout) unsigned short &INOUT = unsigned short &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int (int val, int ecode = 0) {
    ecode = SWIG_AsVal_int($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = ($ltype)(val);
  }
  %typemap(freearg) int "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) const int & ($*ltype temp, int val, int ecode = 0) {  
    ecode = SWIG_AsVal_int($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = ($*ltype)(val);
    $1 = &temp;
  }
  %typemap(freearg) const int& "";
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {int}) int {
    int val;
    int res = SWIG_AsVal_int($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = ($ltype)(val);
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=45,fragment="SWIG_" "AsVal" "_" {int}) int, const int& {
    int res = SWIG_AsVal_int($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      int val; 
      int ecode = SWIG_AsVal_int($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      int val;
      int ecode = SWIG_AsVal_int($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") int *INPUT, int &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=45,fragment="SWIG_" "AsVal" "_" {int}) int *INPUT, int &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_int($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&ptr), $1_descriptor, 0, SWIG_Scilab_GetFuncName()))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {int}) int, const int {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_int((int)($1))))) return SWIG_ERROR; 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {int}) const int& {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_int((int)(*$1))))) return SWIG_ERROR; 
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {int}) int, const int&  {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_int((int)($1))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {int}) int {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_int((int)($value))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {int}) int {
    SWIG_Scilab_Raise(SWIG_From_int((int)($1)), "$type", 0);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   int *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   int &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {int}) int *OUTPUT, int &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_int((*$1))))) return SWIG_ERROR;
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void*)($1), $1_descriptor, new_flags, NULL)))) return SWIG_ERROR;
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) int *INOUT = int *INPUT;
 %typemap(in) int &INOUT = int &INPUT;
 %typemap(typecheck) int *INOUT = int *INPUT;
 %typemap(typecheck) int &INOUT = int &INPUT;
 %typemap(argout) int *INOUT = int *OUTPUT;
 %typemap(argout) int &INOUT = int &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int (unsigned int val, int ecode = 0) {
    ecode = SWIG_AsVal_unsigned_SS_int($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = ($ltype)(val);
  }
  %typemap(freearg) unsigned int "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) const unsigned int & ($*ltype temp, unsigned int val, int ecode = 0) {  
    ecode = SWIG_AsVal_unsigned_SS_int($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = ($*ltype)(val);
    $1 = &temp;
  }
  %typemap(freearg) const unsigned int& "";
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int {
    unsigned int val;
    int res = SWIG_AsVal_unsigned_SS_int($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = ($ltype)(val);
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=40,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int, const unsigned int& {
    int res = SWIG_AsVal_unsigned_SS_int($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      unsigned int val; 
      int ecode = SWIG_AsVal_unsigned_SS_int($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      unsigned int val;
      int ecode = SWIG_AsVal_unsigned_SS_int($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") unsigned int *INPUT, unsigned int &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=40,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int *INPUT, unsigned int &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_unsigned_SS_int($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&ptr), $1_descriptor, 0, SWIG_Scilab_GetFuncName()))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int, const unsigned int {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_unsigned_SS_int((unsigned int)($1))))) return SWIG_ERROR; 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) const unsigned int& {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_unsigned_SS_int((unsigned int)(*$1))))) return SWIG_ERROR; 
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int, const unsigned int&  {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_unsigned_SS_int((unsigned int)($1))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_unsigned_SS_int((unsigned int)($value))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int {
    SWIG_Scilab_Raise(SWIG_From_unsigned_SS_int((unsigned int)($1)), "$type", 0);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   unsigned int *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   unsigned int &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int *OUTPUT, unsigned int &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_unsigned_SS_int((*$1))))) return SWIG_ERROR;
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void*)($1), $1_descriptor, new_flags, NULL)))) return SWIG_ERROR;
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) unsigned int *INOUT = unsigned int *INPUT;
 %typemap(in) unsigned int &INOUT = unsigned int &INPUT;
 %typemap(typecheck) unsigned int *INOUT = unsigned int *INPUT;
 %typemap(typecheck) unsigned int &INOUT = unsigned int &INPUT;
 %typemap(argout) unsigned int *INOUT = unsigned int *OUTPUT;
 %typemap(argout) unsigned int &INOUT = unsigned int &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long (long val, int ecode = 0) {
    ecode = SWIG_AsVal_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = ($ltype)(val);
  }
  %typemap(freearg) long "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) const long & ($*ltype temp, long val, int ecode = 0) {  
    ecode = SWIG_AsVal_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = ($*ltype)(val);
    $1 = &temp;
  }
  %typemap(freearg) const long& "";
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {long}) long {
    long val;
    int res = SWIG_AsVal_long($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = ($ltype)(val);
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=55,fragment="SWIG_" "AsVal" "_" {long}) long, const long& {
    int res = SWIG_AsVal_long($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      long val; 
      int ecode = SWIG_AsVal_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      long val;
      int ecode = SWIG_AsVal_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") long *INPUT, long &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=55,fragment="SWIG_" "AsVal" "_" {long}) long *INPUT, long &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_long($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&ptr), $1_descriptor, 0, SWIG_Scilab_GetFuncName()))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {long}) long, const long {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_long((long)($1))))) return SWIG_ERROR; 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {long}) const long& {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_long((long)(*$1))))) return SWIG_ERROR; 
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {long}) long, const long&  {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_long((long)($1))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {long}) long {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_long((long)($value))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {long}) long {
    SWIG_Scilab_Raise(SWIG_From_long((long)($1)), "$type", 0);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   long *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   long &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {long}) long *OUTPUT, long &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_long((*$1))))) return SWIG_ERROR;
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void*)($1), $1_descriptor, new_flags, NULL)))) return SWIG_ERROR;
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) long *INOUT = long *INPUT;
 %typemap(in) long &INOUT = long &INPUT;
 %typemap(typecheck) long *INOUT = long *INPUT;
 %typemap(typecheck) long &INOUT = long &INPUT;
 %typemap(argout) long *INOUT = long *OUTPUT;
 %typemap(argout) long &INOUT = long &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long (unsigned long val, int ecode = 0) {
    ecode = SWIG_UnsignedInt_AsUnsignedLong(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = ($ltype)(val);
  }
  %typemap(freearg) unsigned long "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) const unsigned long & ($*ltype temp, unsigned long val, int ecode = 0) {  
    ecode = SWIG_UnsignedInt_AsUnsignedLong(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = ($*ltype)(val);
    $1 = &temp;
  }
  %typemap(freearg) const unsigned long& "";
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long {
    unsigned long val;
    int res = SWIG_UnsignedInt_AsUnsignedLong(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = ($ltype)(val);
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=50,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long, const unsigned long& {
    int res = SWIG_UnsignedInt_AsUnsignedLong(pvApiCtx, $input, NULL, SWIG_Scilab_GetFuncName());
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      unsigned long val; 
      int ecode = SWIG_UnsignedInt_AsUnsignedLong(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      unsigned long val;
      int ecode = SWIG_UnsignedInt_AsUnsignedLong(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") unsigned long *INPUT, unsigned long &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=50,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long *INPUT, unsigned long &INPUT {
    void *ptr = 0;
    int res = SWIG_UnsignedInt_AsUnsignedLong(pvApiCtx, $input, 0, SWIG_Scilab_GetFuncName());
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&ptr), $1_descriptor, 0, SWIG_Scilab_GetFuncName()))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long, const unsigned long {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_UnsignedInt_FromUnsignedLong(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (unsigned long)($1), SWIG_Scilab_GetFuncName())))) return SWIG_ERROR; 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) const unsigned long& {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_UnsignedInt_FromUnsignedLong(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (unsigned long)(*$1), SWIG_Scilab_GetFuncName())))) return SWIG_ERROR; 
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long, const unsigned long&  {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_UnsignedInt_FromUnsignedLong(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (unsigned long)($1), SWIG_Scilab_GetFuncName())))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_UnsignedInt_FromUnsignedLong(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (unsigned long)($value), SWIG_Scilab_GetFuncName())))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long {
    SWIG_Scilab_Raise(SWIG_UnsignedInt_FromUnsignedLong(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (unsigned long)($1), SWIG_Scilab_GetFuncName()), "$type", 0);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   unsigned long *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   unsigned long &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long *OUTPUT, unsigned long &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_UnsignedInt_FromUnsignedLong(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (*$1), SWIG_Scilab_GetFuncName())))) return SWIG_ERROR;
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void*)($1), $1_descriptor, new_flags, NULL)))) return SWIG_ERROR;
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) unsigned long *INOUT = unsigned long *INPUT;
 %typemap(in) unsigned long &INOUT = unsigned long &INPUT;
 %typemap(typecheck) unsigned long *INOUT = unsigned long *INPUT;
 %typemap(typecheck) unsigned long &INOUT = unsigned long &INPUT;
 %typemap(argout) unsigned long *INOUT = unsigned long *OUTPUT;
 %typemap(argout) unsigned long &INOUT = unsigned long &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long (long long val, int ecode = 0) {
    ecode = SWIG_AsVal_long_SS_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = ($ltype)(val);
  }
  %typemap(freearg) long long "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) const long long & ($*ltype temp, long long val, int ecode = 0) {  
    ecode = SWIG_AsVal_long_SS_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = ($*ltype)(val);
    $1 = &temp;
  }
  %typemap(freearg) const long long& "";
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {long long}) long long {
    long long val;
    int res = SWIG_AsVal_long_SS_long($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = ($ltype)(val);
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=65,fragment="SWIG_" "AsVal" "_" {long long}) long long, const long long& {
    int res = SWIG_AsVal_long_SS_long($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      long long val; 
      int ecode = SWIG_AsVal_long_SS_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      long long val;
      int ecode = SWIG_AsVal_long_SS_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") long long *INPUT, long long &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=65,fragment="SWIG_" "AsVal" "_" {long long}) long long *INPUT, long long &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_long_SS_long($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&ptr), $1_descriptor, 0, SWIG_Scilab_GetFuncName()))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long, const long long {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciInt64_FromLongLong(pvApiCtx, $result, (long long)($1))))) return SWIG_ERROR; 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {long long}) const long long& {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciInt64_FromLongLong(pvApiCtx, $result, (long long)(*$1))))) return SWIG_ERROR; 
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long, const long long&  {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciInt64_FromLongLong(pvApiCtx, $result, (long long)($1))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciInt64_FromLongLong(pvApiCtx, $result, (long long)($value))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long {
    SWIG_Scilab_Raise(SWIG_SciInt64_FromLongLong(pvApiCtx, $result, (long long)($1)), "$type", 0);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   long long *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   long long &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long *OUTPUT, long long &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciInt64_FromLongLong(pvApiCtx, $result, (*$1))))) return SWIG_ERROR;
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void*)($1), $1_descriptor, new_flags, NULL)))) return SWIG_ERROR;
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) long long *INOUT = long long *INPUT;
 %typemap(in) long long &INOUT = long long &INPUT;
 %typemap(typecheck) long long *INOUT = long long *INPUT;
 %typemap(typecheck) long long &INOUT = long long &INPUT;
 %typemap(argout) long long *INOUT = long long *OUTPUT;
 %typemap(argout) long long &INOUT = long long &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long (unsigned long long val, int ecode = 0) {
    ecode = SWIG_SciUint64_ToUnsignedLongLong(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = ($ltype)(val);
  }
  %typemap(freearg) unsigned long long "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) const unsigned long long & ($*ltype temp, unsigned long long val, int ecode = 0) {  
    ecode = SWIG_SciUint64_ToUnsignedLongLong(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = ($*ltype)(val);
    $1 = &temp;
  }
  %typemap(freearg) const unsigned long long& "";
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long {
    unsigned long long val;
    int res = SWIG_SciUint64_ToUnsignedLongLong(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = ($ltype)(val);
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=60,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long, const unsigned long long& {
    int res = SWIG_SciUint64_ToUnsignedLongLong(pvApiCtx, $input, NULL, SWIG_Scilab_GetFuncName());
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      unsigned long long val; 
      int ecode = SWIG_SciUint64_ToUnsignedLongLong(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      unsigned long long val;
      int ecode = SWIG_SciUint64_ToUnsignedLongLong(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") unsigned long long *INPUT, unsigned long long &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=60,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long *INPUT, unsigned long long &INPUT {
    void *ptr = 0;
    int res = SWIG_SciUint64_ToUnsignedLongLong(pvApiCtx, $input, 0, SWIG_Scilab_GetFuncName());
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&ptr), $1_descriptor, 0, SWIG_Scilab_GetFuncName()))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long, const unsigned long long {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciUint64_FromUnsignedLongLong(pvApiCtx, $result, (unsigned long long)($1))))) return SWIG_ERROR; 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) const unsigned long long& {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciUint64_FromUnsignedLongLong(pvApiCtx, $result, (unsigned long long)(*$1))))) return SWIG_ERROR; 
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long, const unsigned long long&  {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciUint64_FromUnsignedLongLong(pvApiCtx, $result, (unsigned long long)($1))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciUint64_FromUnsignedLongLong(pvApiCtx, $result, (unsigned long long)($value))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long {
    SWIG_Scilab_Raise(SWIG_SciUint64_FromUnsignedLongLong(pvApiCtx, $result, (unsigned long long)($1)), "$type", 0);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   unsigned long long *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   unsigned long long &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long *OUTPUT, unsigned long long &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciUint64_FromUnsignedLongLong(pvApiCtx, $result, (*$1))))) return SWIG_ERROR;
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void*)($1), $1_descriptor, new_flags, NULL)))) return SWIG_ERROR;
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) unsigned long long *INOUT = unsigned long long *INPUT;
 %typemap(in) unsigned long long &INOUT = unsigned long long &INPUT;
 %typemap(typecheck) unsigned long long *INOUT = unsigned long long *INPUT;
 %typemap(typecheck) unsigned long long &INOUT = unsigned long long &INPUT;
 %typemap(argout) unsigned long long *INOUT = unsigned long long *OUTPUT;
 %typemap(argout) unsigned long long &INOUT = unsigned long long &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float (float val, int ecode = 0) {
    ecode = SWIG_AsVal_float($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = ($ltype)(val);
  }
  %typemap(freearg) float "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) const float & ($*ltype temp, float val, int ecode = 0) {  
    ecode = SWIG_AsVal_float($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = ($*ltype)(val);
    $1 = &temp;
  }
  %typemap(freearg) const float& "";
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {float}) float {
    float val;
    int res = SWIG_AsVal_float($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = ($ltype)(val);
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=80,fragment="SWIG_" "AsVal" "_" {float}) float, const float& {
    int res = SWIG_AsVal_float($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      float val; 
      int ecode = SWIG_AsVal_float($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      float val;
      int ecode = SWIG_AsVal_float($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") float *INPUT, float &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=80,fragment="SWIG_" "AsVal" "_" {float}) float *INPUT, float &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_float($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&ptr), $1_descriptor, 0, SWIG_Scilab_GetFuncName()))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {float}) float, const float {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_float((float)($1))))) return SWIG_ERROR; 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {float}) const float& {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_float((float)(*$1))))) return SWIG_ERROR; 
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {float}) float, const float&  {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_float((float)($1))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {float}) float {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_float((float)($value))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {float}) float {
    SWIG_Scilab_Raise(SWIG_From_float((float)($1)), "$type", 0);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   float *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   float &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {float}) float *OUTPUT, float &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_float((*$1))))) return SWIG_ERROR;
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void*)($1), $1_descriptor, new_flags, NULL)))) return SWIG_ERROR;
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) float *INOUT = float *INPUT;
 %typemap(in) float &INOUT = float &INPUT;
 %typemap(typecheck) float *INOUT = float *INPUT;
 %typemap(typecheck) float &INOUT = float &INPUT;
 %typemap(argout) float *INOUT = float *OUTPUT;
 %typemap(argout) float &INOUT = float &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double (double val, int ecode = 0) {
    ecode = SWIG_AsVal_double($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = ($ltype)(val);
  }
  %typemap(freearg) double "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) const double & ($*ltype temp, double val, int ecode = 0) {  
    ecode = SWIG_AsVal_double($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = ($*ltype)(val);
    $1 = &temp;
  }
  %typemap(freearg) const double& "";
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {double}) double {
    double val;
    int res = SWIG_AsVal_double($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = ($ltype)(val);
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=90,fragment="SWIG_" "AsVal" "_" {double}) double, const double& {
    int res = SWIG_AsVal_double($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      double val; 
      int ecode = SWIG_AsVal_double($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      double val;
      int ecode = SWIG_AsVal_double($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") double *INPUT, double &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=90,fragment="SWIG_" "AsVal" "_" {double}) double *INPUT, double &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_double($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&ptr), $1_descriptor, 0, SWIG_Scilab_GetFuncName()))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {double}) double, const double {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_double((double)($1))))) return SWIG_ERROR; 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {double}) const double& {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_double((double)(*$1))))) return SWIG_ERROR; 
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {double}) double, const double&  {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_double((double)($1))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {double}) double {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_double((double)($value))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {double}) double {
    SWIG_Scilab_Raise(SWIG_From_double((double)($1)), "$type", 0);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   double *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   double &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {double}) double *OUTPUT, double &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_double((*$1))))) return SWIG_ERROR;
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void*)($1), $1_descriptor, new_flags, NULL)))) return SWIG_ERROR;
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) double *INOUT = double *INPUT;
 %typemap(in) double &INOUT = double &INPUT;
 %typemap(typecheck) double *INOUT = double *INPUT;
 %typemap(typecheck) double &INOUT = double &INPUT;
 %typemap(argout) double *INOUT = double *OUTPUT;
 %typemap(argout) double &INOUT = double &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char (char val, int ecode = 0) {
    ecode = SWIG_SciString_AsChar(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = ($ltype)(val);
  }
  %typemap(freearg) char "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) const char & ($*ltype temp, char val, int ecode = 0) {  
    ecode = SWIG_SciString_AsChar(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = ($*ltype)(val);
    $1 = &temp;
  }
  %typemap(freearg) const char& "";
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {char}) char {
    char val;
    int res = SWIG_SciString_AsChar(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = ($ltype)(val);
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=130,fragment="SWIG_" "AsVal" "_" {char}) char, const char& {
    int res = SWIG_SciString_AsChar(pvApiCtx, $input, NULL, SWIG_Scilab_GetFuncName());
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      char val; 
      int ecode = SWIG_SciString_AsChar(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      char val;
      int ecode = SWIG_SciString_AsChar(pvApiCtx, $input, &val, SWIG_Scilab_GetFuncName());
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") char *INPUT, char &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=130,fragment="SWIG_" "AsVal" "_" {char}) char *INPUT, char &INPUT {
    void *ptr = 0;
    int res = SWIG_SciString_AsChar(pvApiCtx, $input, 0, SWIG_Scilab_GetFuncName());
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&ptr), $1_descriptor, 0, SWIG_Scilab_GetFuncName()))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {char}) char, const char {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciString_FromChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (char)($1))))) return SWIG_ERROR; 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {char}) const char& {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciString_FromChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (char)(*$1))))) return SWIG_ERROR; 
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {char}) char, const char&  {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciString_FromChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (char)($1))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {char}) char {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciString_FromChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (char)($value))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {char}) char {
    SWIG_Scilab_Raise(SWIG_SciString_FromChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (char)($1)), "$type", 0);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   char *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   char &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {char}) char *OUTPUT, char &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciString_FromChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (*$1))))) return SWIG_ERROR;
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void*)($1), $1_descriptor, new_flags, NULL)))) return SWIG_ERROR;
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) char *INOUT = char *INPUT;
 %typemap(in) char &INOUT = char &INPUT;
 %typemap(typecheck) char *INOUT = char *INPUT;
 %typemap(typecheck) char &INOUT = char &INPUT;
 %typemap(argout) char *INOUT = char *OUTPUT;
 %typemap(argout) char &INOUT = char &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t (wchar_t val, int ecode = 0) {
    ecode = SWIG_AsVal_wchar_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = ($ltype)(val);
  }
  %typemap(freearg) wchar_t "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) const wchar_t & ($*ltype temp, wchar_t val, int ecode = 0) {  
    ecode = SWIG_AsVal_wchar_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = ($*ltype)(val);
    $1 = &temp;
  }
  %typemap(freearg) const wchar_t& "";
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t {
    wchar_t val;
    int res = SWIG_AsVal_wchar_t($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = ($ltype)(val);
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=110,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t, const wchar_t& {
    int res = SWIG_AsVal_wchar_t($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      wchar_t val; 
      int ecode = SWIG_AsVal_wchar_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      wchar_t val;
      int ecode = SWIG_AsVal_wchar_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") wchar_t *INPUT, wchar_t &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=110,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t *INPUT, wchar_t &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_wchar_t($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&ptr), $1_descriptor, 0, SWIG_Scilab_GetFuncName()))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t, const wchar_t {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_wchar_t((wchar_t)($1))))) return SWIG_ERROR; 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) const wchar_t& {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_wchar_t((wchar_t)(*$1))))) return SWIG_ERROR; 
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t, const wchar_t&  {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_wchar_t((wchar_t)($1))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_wchar_t((wchar_t)($value))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t {
    SWIG_Scilab_Raise(SWIG_From_wchar_t((wchar_t)($1)), "$type", 0);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   wchar_t *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   wchar_t &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t *OUTPUT, wchar_t &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_wchar_t((*$1))))) return SWIG_ERROR;
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void*)($1), $1_descriptor, new_flags, NULL)))) return SWIG_ERROR;
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) wchar_t *INOUT = wchar_t *INPUT;
 %typemap(in) wchar_t &INOUT = wchar_t &INPUT;
 %typemap(typecheck) wchar_t *INOUT = wchar_t *INPUT;
 %typemap(typecheck) wchar_t &INOUT = wchar_t &INPUT;
 %typemap(argout) wchar_t *INOUT = wchar_t *OUTPUT;
 %typemap(argout) wchar_t &INOUT = wchar_t &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t (size_t val, int ecode = 0) {
    ecode = SWIG_AsVal_size_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = ($ltype)(val);
  }
  %typemap(freearg) size_t "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) const size_t & ($*ltype temp, size_t val, int ecode = 0) {  
    ecode = SWIG_AsVal_size_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = ($*ltype)(val);
    $1 = &temp;
  }
  %typemap(freearg) const size_t& "";
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {size_t}) size_t {
    size_t val;
    int res = SWIG_AsVal_size_t($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = ($ltype)(val);
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=47,fragment="SWIG_" "AsVal" "_" {size_t}) size_t, const size_t& {
    int res = SWIG_AsVal_size_t($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      size_t val; 
      int ecode = SWIG_AsVal_size_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      size_t val;
      int ecode = SWIG_AsVal_size_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") size_t *INPUT, size_t &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=47,fragment="SWIG_" "AsVal" "_" {size_t}) size_t *INPUT, size_t &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_size_t($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&ptr), $1_descriptor, 0, SWIG_Scilab_GetFuncName()))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t, const size_t {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_size_t((size_t)($1))))) return SWIG_ERROR; 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {size_t}) const size_t& {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_size_t((size_t)(*$1))))) return SWIG_ERROR; 
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t, const size_t&  {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_size_t((size_t)($1))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_size_t((size_t)($value))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t {
    SWIG_Scilab_Raise(SWIG_From_size_t((size_t)($1)), "$type", 0);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   size_t *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   size_t &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t *OUTPUT, size_t &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_size_t((*$1))))) return SWIG_ERROR;
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void*)($1), $1_descriptor, new_flags, NULL)))) return SWIG_ERROR;
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) size_t *INOUT = size_t *INPUT;
 %typemap(in) size_t &INOUT = size_t &INPUT;
 %typemap(typecheck) size_t *INOUT = size_t *INPUT;
 %typemap(typecheck) size_t &INOUT = size_t &INPUT;
 %typemap(argout) size_t *INOUT = size_t *OUTPUT;
 %typemap(argout) size_t &INOUT = size_t &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t (ptrdiff_t val, int ecode = 0) {
    ecode = SWIG_AsVal_ptrdiff_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = ($ltype)(val);
  }
  %typemap(freearg) ptrdiff_t "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) const ptrdiff_t & ($*ltype temp, ptrdiff_t val, int ecode = 0) {  
    ecode = SWIG_AsVal_ptrdiff_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = ($*ltype)(val);
    $1 = &temp;
  }
  %typemap(freearg) const ptrdiff_t& "";
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t {
    ptrdiff_t val;
    int res = SWIG_AsVal_ptrdiff_t($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = ($ltype)(val);
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=48,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t, const ptrdiff_t& {
    int res = SWIG_AsVal_ptrdiff_t($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      ptrdiff_t val; 
      int ecode = SWIG_AsVal_ptrdiff_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&$1), $descriptor, $disown, SWIG_Scilab_GetFuncName()))))) {
      ptrdiff_t val;
      int ecode = SWIG_AsVal_ptrdiff_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = ($*ltype)(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") ptrdiff_t *INPUT, ptrdiff_t &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=48,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t *INPUT, ptrdiff_t &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_ptrdiff_t($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SwigScilabPtrToObject(pvApiCtx, $input, SWIG_as_voidptrptr(&ptr), $1_descriptor, 0, SWIG_Scilab_GetFuncName()))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t, const ptrdiff_t {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_ptrdiff_t((ptrdiff_t)($1))))) return SWIG_ERROR; 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) const ptrdiff_t& {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_ptrdiff_t((ptrdiff_t)(*$1))))) return SWIG_ERROR; 
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t, const ptrdiff_t&  {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_ptrdiff_t((ptrdiff_t)($1))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t {
    if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_ptrdiff_t((ptrdiff_t)($value))))) return SWIG_ERROR;
  }
/*@SWIG@*/;
  ;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t {
    SWIG_Scilab_Raise(SWIG_From_ptrdiff_t((ptrdiff_t)($1)), "$type", 0);
  }
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   ptrdiff_t *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   ptrdiff_t &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t *OUTPUT, ptrdiff_t &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_From_ptrdiff_t((*$1))))) return SWIG_ERROR;
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SwigScilabPtrFromObject(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (void*)($1), $1_descriptor, new_flags, NULL)))) return SWIG_ERROR;
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) ptrdiff_t *INOUT = ptrdiff_t *INPUT;
 %typemap(in) ptrdiff_t &INOUT = ptrdiff_t &INPUT;
 %typemap(typecheck) ptrdiff_t *INOUT = ptrdiff_t *INPUT;
 %typemap(typecheck) ptrdiff_t &INOUT = ptrdiff_t &INPUT;
 %typemap(argout) ptrdiff_t *INOUT = ptrdiff_t *OUTPUT;
 %typemap(argout) ptrdiff_t &INOUT = ptrdiff_t &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG@*/;

%endoffile
%includefile "/usr/local/share/swig/4.0.0/typemaps/string.swg" %beginfile
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,285,%ensure_fragment@*/
%fragment("SWIG_AsCharPtrAndSize","header") {
#error "SWIG language implementation must provide the SWIG_AsCharPtrAndSize fragment"
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/fragments.swg,285,%ensure_fragment@*/
%fragment("SWIG_FromCharPtrAndSize","header") {
#error "SWIG language implementation must provide the SWIG_FromCharPtrAndSize fragment"
}
/*@SWIG@*/

%types(char *);

%fragment("SWIG_pchar_descriptor","header") {
SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}
}

%fragment("SWIG_strnlen","header",fragment="SWIG_FromCharPtrAndSize") {
SWIGINTERN size_t
SWIG_strnlen(const char* s, size_t maxlen)
{
  const char *p;
  for (p = s; maxlen-- && *p; p++)
    ;
  return p - s;
}
}

%includefile "/usr/local/share/swig/4.0.0/typemaps/strings.swg" %beginfile
//
// Use the macro SWIG_PRESERVE_CARRAY_SIZE if you prefer to preserve
// the size of char arrays, ie
//  ------------------------------------------
//       C Side             =>   Language Side
//  ------------------------------------------
//   char name[5] = "hola"  =>   'hola\0'
//
// the default behaviour is 
//
//   char name[5] = "hola"  =>   'hola'
//
//
//#define SWIG_PRESERVE_CARRAY_SIZE

/* ------------------------------------------------------------
 *  String typemaps for type Char (char or wchar_t)
 * ------------------------------------------------------------ */































































































































































































































































































































































































































































































/* ------------------------------------------------------------
 * --- String fragment methods ---
 * ------------------------------------------------------------ */










































































































/* ------------------------------------------------------------
 *  String typemaps and fragments, with default allocators
 * ------------------------------------------------------------ */



















/* ------------------------------------------------------------
 *  String typemaps and fragments, with custom allocators
 * ------------------------------------------------------------ */




















%endoffile
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/strings.swg,611,%typemaps_string@*/
/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/strings.swg,503,%_typemap2_string@*/
  
%fragment("SWIG_From""Char""Ptr","header",fragment="SWIG_FromCharPtrAndSize") {
SWIGINTERNINLINE int 
SWIG_SciString_FromCharPtr(pvApiCtx, SWIG_Scilab_GetOutputPosition(), const char *cptr)
{ 
  return SWIG_SciString_FromCharPtr(pvApiCtx, SWIG_Scilab_GetOutputPosition(), cptr);
}
}

%fragment("SWIG_From""Char""Array","header",fragment="SWIG_FromCharPtrAndSize") {
SWIGINTERNINLINE int 
SWIG_FromCharArray(const char *cptr, size_t size)
{ 
  return SWIG_SciString_FromCharPtr(pvApiCtx, SWIG_Scilab_GetOutputPosition(), cptr);
}
}

%fragment("SWIG_As""Char" "Ptr","header",fragment="SWIG_AsCharPtrAndSize") {

}

%fragment("SWIG_As""Char" "Array","header",fragment="SWIG_AsCharPtrAndSize") {
SWIGINTERN int
SWIG_SciString_AsCharPtr(pvApiCtx, int obj, char *val, size_t size, SWIG_Scilab_GetFuncName())
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_SciString_AsCharPtrAndSize(pvApiCtx, obj, &cptr, &csize, &alloc, SWIG_Scilab_GetFuncName());
  if (SWIG_IsOK(res)) {
    /* special case of single char conversion when we don't need space for NUL */
    if (size == 1 && csize == 2 && cptr && !cptr[1]) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	delete[] cptr;
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) delete[] cptr;
  }
  return SWIG_TypeError;
}
}

/* char */

%fragment("SWIG_" "From" "_" {char},"header",fragment="SWIG_FromCharPtrAndSize") {
SWIGINTERNINLINE int
SWIG_SciString_FromChar(pvApiCtx, SWIG_Scilab_GetOutputPosition(), char c) 
{ 
  return SWIG_SciString_FromCharPtr(pvApiCtx, SWIG_Scilab_GetOutputPosition(), &c);
}
}

%fragment("SWIG_" "AsVal" "_" {char},"header",
	  fragment="SWIG_As""Char""Array",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_SciString_AsChar(pvApiCtx, int obj, char *val, SWIG_Scilab_GetFuncName())
{    
  int res = SWIG_SciString_AsCharPtr(pvApiCtx, obj, val, 1, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = (char)(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}
}

/*@SWIG:/usr/local/share/swig/4.0.0/typemaps/strings.swg,20,%_typemap_string@*/

/* in */

%typemap(in,noblock=1,fragment="SWIG_AsCharPtr") 
  char * (int res, char *buf = 0, int alloc = 0),
  const char * (int res, char *buf = 0, int alloc = 0) {
  res = SWIG_SciString_AsCharPtrAndSize(pvApiCtx, $input, &buf, NULL, &alloc, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $1 = ($1_ltype)(buf);
}
%typemap(freearg,noblock=1,match="in") char *, const char * {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}

%typemap(in,noblock=1,fragment="SWIG_AsCharPtr") char const*& (int res, char *buf = 0, int alloc = 0) {
  res = SWIG_SciString_AsCharPtrAndSize(pvApiCtx, $input, &buf, NULL, &alloc, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $1 = &buf;
}    
%typemap(freearg, noblock=1,match="in") char const*& {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}

/* out */

%typemap(out,noblock=1,fragment="SWIG_FromCharPtr") char *, const char * {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciString_FromCharPtr(pvApiCtx, SWIG_Scilab_GetOutputPosition(), (const char *)$1)))) return SWIG_ERROR;
}


%typemap(out,noblock=1,fragment="SWIG_FromCharPtr") char const*& {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciString_FromCharPtr(pvApiCtx, SWIG_Scilab_GetOutputPosition(), *$1)))) return SWIG_ERROR;
}

%typemap(newfree,noblock=1) char * {
  delete[] $1;
}

/* varin */

%typemap(varin,fragment="SWIG_AsCharPtrAndSize") char * {
  char *cptr = 0; size_t csize = 0; int alloc = SWIG_NEWOBJ;
  int res = SWIG_SciString_AsCharPtrAndSize(pvApiCtx, $input, &cptr, &csize, &alloc, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  if ($1) delete[] $1;
  if (alloc == SWIG_NEWOBJ) {
    $1 = cptr;
  } else {
    $1 = csize ? ($1_type)(char*)(memcpy(new char[csize], cptr, sizeof(char)*(csize))) : 0;
  }
}

%typemap(varin,fragment="SWIG_AsCharPtrAndSize",warning=        "451:Setting a const char * variable may leak memory." ) const char * {
  char *cptr = 0; size_t csize = 0; int alloc = SWIG_NEWOBJ;
  int res = SWIG_SciString_AsCharPtrAndSize(pvApiCtx, $input, &cptr, &csize, &alloc, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  if (alloc == SWIG_NEWOBJ) {
    $1 = cptr;
  } else {
    $1 = csize ? ($1_type)(char*)(memcpy(new char[csize], cptr, sizeof(char)*(csize))) : 0;
  }
}

/* varout */

%typemap(varout,noblock=1,fragment="SWIG_FromCharPtr") char *, const char * {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciString_FromCharPtr(pvApiCtx, SWIG_Scilab_GetOutputPosition(), $1)))) return SWIG_ERROR;
}

/* memberin */

%typemap(memberin,noblock=1) char * {
  if ($1) delete[] $1;
  if ($input) {
    size_t size = strlen((const char *)($input)) + 1;
    $1 = ($1_type)(char*)(memcpy(new char[size], (const char *)($input), sizeof(char)*(size)));
  } else {
    $1 = 0;
  }
}

%typemap(memberin,noblock=1,warning=        "451:Setting a const char * variable may leak memory." ) const char * {
  if ($input) {
    size_t size = strlen((const char *)((const char *)($input))) + 1;
    $1 = ($1_type)(char*)(memcpy(new char[size], $input, sizeof(char)*(size)));
  } else {
    $1 = 0;
  }
}

/* globalin */

%typemap(globalin,noblock=1) char * {
  if ($1) delete[] $1;
  if ($input) {
    size_t size = strlen((const char *)((const char *)($input))) + 1;
    $1 = ($1_type)(char*)(memcpy(new char[size], $input, sizeof(char)*(size)));
  } else {
    $1 = 0;
  }
}

%typemap(globalin,noblock=1,warning=        "451:Setting a const char * variable may leak memory." ) const char * {
  if ($input) {
    size_t size = strlen($input) + 1;
    $1 = ($1_type)(char*)(memcpy(new char[size], $input, sizeof(char)*(size)));
  } else {
    $1 = 0;
  }
}

/* constant */

%typemap(constcode,noblock=1,fragment="SWIG_FromCharPtr")
  char *, char const*, char * const, char const* const {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciString_FromCharPtr(pvApiCtx, SWIG_Scilab_GetOutputPosition(), $value)))) return SWIG_ERROR;
}





















































/* typecheck */

%typemap(typecheck,noblock=1,precedence=140,
	 fragment="SWIG_AsCharPtr") char *, const char *, char const*& {
  int res = SWIG_SciString_AsCharPtrAndSize(pvApiCtx, $input, 0, NULL, 0, SWIG_Scilab_GetFuncName());
  $1 = SWIG_CheckState(res);
}


/* throws */

%typemap(throws,noblock=1,fragment="SWIG_FromCharPtr") char * {
  SWIG_Scilab_Raise(SWIG_SciString_FromCharPtr(pvApiCtx, SWIG_Scilab_GetOutputPosition(), $1), "$type", 0);
}


/* ------------------------------------------------------------
 *  Unknown size const Character array char[ANY] handling
 * ------------------------------------------------------------ */

%apply char * { char [] };
%apply const char * { const char [] };

%typemap(varin,noblock=1,warning="462:Unable to set variable of type char []") char []
{
  SWIG_exception_fail(SWIG_ArgError(SWIG_AttributeError), "in variable '""read-only $name""' of type '""$type""'");
}


/* ------------------------------------------------------------
 *  Fixed size Character array char[ANY] handling
 * ------------------------------------------------------------ */

/*  memberin and globalin typemaps  */

%typemap(memberin,noblock=1) char [ANY]
{
  if ($input) memcpy($1,$input,$1_dim0*sizeof(char));
  else memset($1,0,$1_dim0*sizeof(char));
}

%typemap(globalin,noblock=1) char [ANY]
{
  if ($input) memcpy($1,$input,$1_dim0*sizeof(char));
  else memset($1,0,$1_dim0*sizeof(char));
}

/* in */

%typemap(in,noblock=1,fragment="SWIG_AsCharArray")
  char [ANY] (char temp[$1_dim0], int res), 
  const char [ANY](char temp[$1_dim0], int res)
{  
  res = SWIG_SciString_AsCharPtr(pvApiCtx, $input, temp, $1_dim0, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $1 = ($1_ltype)(temp);
}
%typemap(freearg) char [ANY], const char [ANY] "";

%typemap(in,noblock=1,fragment="SWIG_AsCharArray") const char (&)[ANY] (char temp[$1_dim0], int res)
{  
  res = SWIG_SciString_AsCharPtr(pvApiCtx, $input, temp, $1_dim0, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $1 = &temp;
}
%typemap(freearg) const char (&)[ANY] "";

%typemap(out,fragment="SWIG_FromCharPtrAndSize",fragment="SWIG_strnlen")
  char [ANY], const char[ANY] 
{

  size_t size = SWIG_strnlen($1, $1_dim0);



   if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciString_FromCharPtr(pvApiCtx, SWIG_Scilab_GetOutputPosition(), $1)))) return SWIG_ERROR;
}

/* varin */

%typemap(varin,fragment="SWIG_AsCharArray") char [ANY]
{
  int res = SWIG_SciString_AsCharPtr(pvApiCtx, $input, $1, $1_dim0, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
}

/* varout */

%typemap(varout,fragment="SWIG_strnlen")
  char [ANY], const char [ANY] {

  size_t size = SWIG_strnlen($1, $1_dim0);



  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciString_FromCharPtr(pvApiCtx, SWIG_Scilab_GetOutputPosition(), $1)))) return SWIG_ERROR;
}

/* constant */

%typemap(constcode,fragment="SWIG_strnlen")
  char [ANY], const char [ANY]
{

  size_t size = SWIG_strnlen($1, $1_dim0);



  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciString_FromCharPtr(pvApiCtx, SWIG_Scilab_GetOutputPosition(), $value)))) return SWIG_ERROR;
}































/* typecheck */

%typemap(typecheck,noblock=1,precedence=140,
	 fragment="SWIG_AsCharArray")  
  char [ANY], const char[ANY] {
  int res = SWIG_SciString_AsCharPtr(pvApiCtx, $input, (char *)0, $1_dim0, SWIG_Scilab_GetFuncName());
  $1 = SWIG_CheckState(res);
}


/* throws */

%typemap(throws,fragment="SWIG_strnlen")
  char [ANY], const char[ANY]
{

  size_t size = SWIG_strnlen($1, $1_dim0);



  SWIG_Scilab_Raise(SWIG_SciString_FromCharPtr(pvApiCtx, SWIG_Scilab_GetOutputPosition(), $1), "$type", 0); 
}

/* -------------------------------------------------------------------
 * --- Really fix size char arrays, including '\0'chars at the end ---
 * ------------------------------------------------------------------- */

%typemap(varout,noblock=1,fragment="SWIG_FromCharPtrAndSize")
  char FIXSIZE[ANY], const char FIXSIZE[ANY]
{
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciString_FromCharPtr(pvApiCtx, SWIG_Scilab_GetOutputPosition(), $1)))) return SWIG_ERROR;
}

%typemap(out,noblock=1,fragment="SWIG_FromCharPtrAndSize")
  char FIXSIZE[ANY], const char FIXSIZE[ANY]
{
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciString_FromCharPtr(pvApiCtx, SWIG_Scilab_GetOutputPosition(), $1)))) return SWIG_ERROR;
}











%typemap(throws,noblock=1,fragment="SWIG_FromCharPtrAndSize")
  char FIXSIZE[ANY], const char FIXSIZE[ANY] {
  SWIG_Scilab_Raise(SWIG_SciString_FromCharPtr(pvApiCtx, SWIG_Scilab_GetOutputPosition(), $1), "$type", 0); 
}

/* ------------------------------------------------------------
 * --- String & length ---
 * ------------------------------------------------------------ */

/* Here len doesn't include the '0' terminator */
%typemap(in,noblock=1,fragment="SWIG_AsCharPtrAndSize") 
  (char *STRING, size_t LENGTH) (int res, char *buf = 0, size_t size = 0, int alloc = 0),
  (const char *STRING, size_t LENGTH) (int res, char *buf = 0, size_t size = 0, int alloc = 0)
{
  res = SWIG_SciString_AsCharPtrAndSize(pvApiCtx, $input, &buf, &size, &alloc, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }  
  $1 = ($1_ltype)(buf);
  $2 = ($2_ltype)(size - 1);
}
%typemap(freearg,noblock=1,match="in") (char *STRING, size_t LENGTH) {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}
/* old 'int' form */
%typemap(in) (char *STRING, int LENGTH) = (char *STRING, size_t LENGTH);
%typemap(freearg) (char *STRING, int LENGTH) = (char *STRING, size_t LENGTH);


/* Here size includes the '0' terminator */
%typemap(in,noblock=1,fragment="SWIG_AsCharPtrAndSize")
  (char *STRING, size_t SIZE) (int res, char *buf = 0, size_t size = 0, int alloc = 0),
  (const char *STRING, size_t SIZE) (int res, char *buf = 0, size_t size = 0, int alloc = 0)
{
  res = SWIG_SciString_AsCharPtrAndSize(pvApiCtx, $input, &buf, &size, &alloc, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $1 = ($1_ltype)(buf);
  $2 = ($2_ltype)(size);
}
%typemap(freearg,noblock=1,match="in") (char *STRING, size_t SIZE) {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}
/* old 'int' form */
%typemap(in) (char *STRING, int SIZE) = (char *STRING, size_t SIZE);
%typemap(freearg) (char *STRING, int SIZE) = (char *STRING, size_t SIZE);


/* reverse order versions */

/* Here len doesn't include the '0' terminator */
%typemap(in,noblock=1,fragment="SWIG_AsCharPtrAndSize") 
  (size_t LENGTH, char *STRING) (int res, char *buf = 0, size_t size = 0, int alloc = 0),
  (size_t LENGTH, const char *STRING) (int res, char *buf = 0, size_t size = 0, int alloc = 0)
{
  res = SWIG_SciString_AsCharPtrAndSize(pvApiCtx, $input, &buf, &size, &alloc, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }  
  $2 = ($2_ltype)(buf) ;
  $1 = ($1_ltype)(size - 1) ;
}
%typemap(freearg, noblock=1, match="in") (size_t LENGTH, char *STRING) {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}
/* old 'int' form */
%typemap(in) (int LENGTH, char *STRING) = (size_t LENGTH, char *STRING);
%typemap(freearg) (int LENGTH, char *STRING) = (size_t LENGTH, char *STRING);

/* Here size includes the '0' terminator */
%typemap(in,noblock=1,fragment="SWIG_AsCharPtrAndSize")
  (size_t SIZE, char *STRING) (int res, char *buf = 0, size_t size = 0, int alloc = 0),
  (size_t SIZE, const char *STRING) (int res, char *buf = 0, size_t size = 0, int alloc = 0)
{
  res = SWIG_SciString_AsCharPtrAndSize(pvApiCtx, $input, &buf, &size, &alloc, SWIG_Scilab_GetFuncName());
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $2 = ($2_ltype)(buf) ;
  $1 = ($1_ltype)(size) ;
}
%typemap(freearg, noblock=1, match="in") (size_t SIZE, char *STRING) {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}
/* old 'int' form */
%typemap(in) (int SIZE, char *STRING) = (size_t SIZE, char *STRING);
%typemap(freearg) (int SIZE, char *STRING) = (size_t SIZE, char *STRING);


/*@SWIG@*/











/*@SWIG@*/








/*@SWIG@*/



%endoffile
%includefile "/usr/local/share/swig/4.0.0/typemaps/misctypes.swg" %beginfile

/* ------------------------------------------------------------
 * --- ANSI/Posix C/C++ types ---
 * ------------------------------------------------------------ */




%apply size_t { std::size_t };
%apply const size_t& { const std::size_t& };

%apply ptrdiff_t { std::ptrdiff_t };
%apply const ptrdiff_t& { const std::ptrdiff_t& };


%apply size_t& { std::size_t& };
%apply ptrdiff_t& { std::ptrdiff_t& };




%endoffile
%includefile "/usr/local/share/swig/4.0.0/typemaps/enumint.swg" %beginfile
/* ------------------------------------------------------------
 *  Enums mapped as integer values
 * ------------------------------------------------------------ */

%apply int { enum SWIGTYPE };
%apply const int& { const enum SWIGTYPE & };
%apply const int& { const enum SWIGTYPE && };

%typemap(in,fragment="SWIG_" "AsVal" "_" {int},noblock=1) const enum SWIGTYPE & (int val, int ecode, $basetype temp) {  
  ecode = SWIG_AsVal_int ($input, &val);
  if (!SWIG_IsOK(ecode)) {
    SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  } else {
    temp = ($basetype)(val);
    $1 = &temp;
  }
}

%typemap(in,fragment="SWIG_" "AsVal" "_" {int},noblock=1) const enum SWIGTYPE && (int val, int ecode, $basetype temp) {  
  ecode = SWIG_AsVal_int ($input, &val);
  if (!SWIG_IsOK(ecode)) {
    SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  } else {
    temp = ($basetype)(val);
    $1 = &temp;
  }
}

%typemap(varin,fragment="SWIG_" "AsVal" "_" {int},noblock=1) enum SWIGTYPE {
  if (sizeof(int) != sizeof($1)) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_AttributeError), "in variable '""arch, read-only $name""' of type '""$type""'");
  }  else {
    int ecode = SWIG_AsVal_int ($input, (int*)(&$1));
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in variable '""$name""' of type '""$type""'");
    }
  }
}

%endoffile


%endoffile

/* ---------------------------------------------------------------------------*/
/* Generic typmemaps                                                          */
/*                                                                            */
/* This typemap is used when Scilab does not store this type directly         */
/* For example, a 'float' is stored in Scilab as a 'double'                   */
/* So we read a 'double' in Scilab and cast it to a 'float'                   */
/* ---------------------------------------------------------------------------*/



























































/* ---------------------------------------------------------------------------*/
/* Array typmemaps                                                            */
/* ---------------------------------------------------------------------------*/

%includefile "/usr/local/share/swig/4.0.0/scilab/sciarray.swg" %beginfile
/* --------------------------------------------------------------------------
 *
 *  Arrays typemaps
 *
 * --------------------------------------------------------------------------*/

%{
#include <stdio.h>
%}

























































// Double
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,56,%scilab_array_typemaps@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,27,%scilab_asarrayandsize_withcopy@*/
%typemap(varin, fragment="SWIG_SciDouble_AsDoubleArrayAndSize") double[ANY] {
  int iRows = 0;
  int iCols = 0;
  double *pTempData = NULL;
  if (SWIG_SciDouble_AsDoubleArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  if (iRows*iCols <= $1_dim0) {
    size_t i;
    for (i = 0; i < $1_dim0; i++) {
      $1[i] = ($*1_ltype) pTempData[i];
    }
  }
  else {
    char errmsg[100];
    sprintf(errmsg, "Size of input data (%d) is too big (maximum is %d)",
      iRows*iCols, $1_dim0);
    SWIG_exception_fail(SWIG_OverflowError, errmsg);
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDouble_AsDoubleArrayAndSize") double[ANY] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  double *pTempData = NULL;
  if (SWIG_SciDouble_AsDoubleArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(varout, noblock=1, fragment="SWIG_SciDouble_FromDoubleArrayAndSize") double[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromDoubleArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(out, noblock=1, fragment="SWIG_SciDouble_FromDoubleArrayAndSize") double[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromDoubleArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;

  %apply SWIGTYPE[] { double[] };
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDouble_AsDoubleArrayAndSize") double[] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  double *pTempData = NULL;
  if (SWIG_SciDouble_AsDoubleArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
/*@SWIG@*/
;

// Signed char

/*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,56,%scilab_array_typemaps@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,27,%scilab_asarrayandsize_withcopy@*/
%typemap(varin, fragment="SWIG_SciDoubleOrInt8_AsSignedCharArrayAndSize") signed char[ANY] {
  int iRows = 0;
  int iCols = 0;
  signed char *pTempData = NULL;
  if (SWIG_SciDoubleOrInt8_AsSignedCharArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  if (iRows*iCols <= $1_dim0) {
    size_t i;
    for (i = 0; i < $1_dim0; i++) {
      $1[i] = ($*1_ltype) pTempData[i];
    }
  }
  else {
    char errmsg[100];
    sprintf(errmsg, "Size of input data (%d) is too big (maximum is %d)",
      iRows*iCols, $1_dim0);
    SWIG_exception_fail(SWIG_OverflowError, errmsg);
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDoubleOrInt8_AsSignedCharArrayAndSize") signed char[ANY] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  signed char *pTempData = NULL;
  if (SWIG_SciDoubleOrInt8_AsSignedCharArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(varout, noblock=1, fragment="SWIG_SciDouble_FromSignedCharArrayAndSize") signed char[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromSignedCharArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(out, noblock=1, fragment="SWIG_SciDouble_FromSignedCharArrayAndSize") signed char[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromSignedCharArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;

  %apply SWIGTYPE[] { signed char[] };
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDoubleOrInt8_AsSignedCharArrayAndSize") signed char[] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  signed char *pTempData = NULL;
  if (SWIG_SciDoubleOrInt8_AsSignedCharArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
/*@SWIG@*/
;

// Unsigned char
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,56,%scilab_array_typemaps@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,27,%scilab_asarrayandsize_withcopy@*/
%typemap(varin, fragment="SWIG_SciDoubleOrUint8_AsUnsignedCharArrayAndSize") unsigned char[ANY] {
  int iRows = 0;
  int iCols = 0;
  unsigned char *pTempData = NULL;
  if (SWIG_SciDoubleOrUint8_AsUnsignedCharArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  if (iRows*iCols <= $1_dim0) {
    size_t i;
    for (i = 0; i < $1_dim0; i++) {
      $1[i] = ($*1_ltype) pTempData[i];
    }
  }
  else {
    char errmsg[100];
    sprintf(errmsg, "Size of input data (%d) is too big (maximum is %d)",
      iRows*iCols, $1_dim0);
    SWIG_exception_fail(SWIG_OverflowError, errmsg);
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDoubleOrUint8_AsUnsignedCharArrayAndSize") unsigned char[ANY] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  unsigned char *pTempData = NULL;
  if (SWIG_SciDoubleOrUint8_AsUnsignedCharArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(varout, noblock=1, fragment="SWIG_SciDouble_FromUnsignedCharArrayAndSize") unsigned char[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromUnsignedCharArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(out, noblock=1, fragment="SWIG_SciDouble_FromUnsignedCharArrayAndSize") unsigned char[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromUnsignedCharArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;

  %apply SWIGTYPE[] { unsigned char[] };
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDoubleOrUint8_AsUnsignedCharArrayAndSize") unsigned char[] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  unsigned char *pTempData = NULL;
  if (SWIG_SciDoubleOrUint8_AsUnsignedCharArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
/*@SWIG@*/
;

// Short
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,56,%scilab_array_typemaps@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,27,%scilab_asarrayandsize_withcopy@*/
%typemap(varin, fragment="SWIG_SciDoubleOrInt16_AsShortArrayAndSize") short[ANY] {
  int iRows = 0;
  int iCols = 0;
  short *pTempData = NULL;
  if (SWIG_SciDoubleOrInt16_AsShortArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  if (iRows*iCols <= $1_dim0) {
    size_t i;
    for (i = 0; i < $1_dim0; i++) {
      $1[i] = ($*1_ltype) pTempData[i];
    }
  }
  else {
    char errmsg[100];
    sprintf(errmsg, "Size of input data (%d) is too big (maximum is %d)",
      iRows*iCols, $1_dim0);
    SWIG_exception_fail(SWIG_OverflowError, errmsg);
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDoubleOrInt16_AsShortArrayAndSize") short[ANY] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  short *pTempData = NULL;
  if (SWIG_SciDoubleOrInt16_AsShortArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(varout, noblock=1, fragment="SWIG_SciDouble_FromShortArrayAndSize") short[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromShortArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(out, noblock=1, fragment="SWIG_SciDouble_FromShortArrayAndSize") short[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromShortArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;

  %apply SWIGTYPE[] { short[] };
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDoubleOrInt16_AsShortArrayAndSize") short[] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  short *pTempData = NULL;
  if (SWIG_SciDoubleOrInt16_AsShortArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
/*@SWIG@*/
;

// Unsigned short
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,56,%scilab_array_typemaps@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,27,%scilab_asarrayandsize_withcopy@*/
%typemap(varin, fragment="SWIG_SciDoubleOrUint16_AsUnsignedShortArrayAndSize") unsigned short[ANY] {
  int iRows = 0;
  int iCols = 0;
  unsigned short *pTempData = NULL;
  if (SWIG_SciDoubleOrUint16_AsUnsignedShortArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  if (iRows*iCols <= $1_dim0) {
    size_t i;
    for (i = 0; i < $1_dim0; i++) {
      $1[i] = ($*1_ltype) pTempData[i];
    }
  }
  else {
    char errmsg[100];
    sprintf(errmsg, "Size of input data (%d) is too big (maximum is %d)",
      iRows*iCols, $1_dim0);
    SWIG_exception_fail(SWIG_OverflowError, errmsg);
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDoubleOrUint16_AsUnsignedShortArrayAndSize") unsigned short[ANY] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  unsigned short *pTempData = NULL;
  if (SWIG_SciDoubleOrUint16_AsUnsignedShortArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(varout, noblock=1, fragment="SWIG_SciDouble_FromUnsignedShortArrayAndSize") unsigned short[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromUnsignedShortArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(out, noblock=1, fragment="SWIG_SciDouble_FromUnsignedShortArrayAndSize") unsigned short[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromUnsignedShortArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;

  %apply SWIGTYPE[] { unsigned short[] };
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDoubleOrUint16_AsUnsignedShortArrayAndSize") unsigned short[] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  unsigned short *pTempData = NULL;
  if (SWIG_SciDoubleOrUint16_AsUnsignedShortArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
/*@SWIG@*/
;

// Int
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,56,%scilab_array_typemaps@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,27,%scilab_asarrayandsize_withcopy@*/
%typemap(varin, fragment="SWIG_SciDoubleOrInt32_AsIntArrayAndSize") int[ANY] {
  int iRows = 0;
  int iCols = 0;
  int *pTempData = NULL;
  if (SWIG_SciDoubleOrInt32_AsIntArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  if (iRows*iCols <= $1_dim0) {
    size_t i;
    for (i = 0; i < $1_dim0; i++) {
      $1[i] = ($*1_ltype) pTempData[i];
    }
  }
  else {
    char errmsg[100];
    sprintf(errmsg, "Size of input data (%d) is too big (maximum is %d)",
      iRows*iCols, $1_dim0);
    SWIG_exception_fail(SWIG_OverflowError, errmsg);
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDoubleOrInt32_AsIntArrayAndSize") int[ANY] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  int *pTempData = NULL;
  if (SWIG_SciDoubleOrInt32_AsIntArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(varout, noblock=1, fragment="SWIG_SciDouble_FromIntArrayAndSize") int[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromIntArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(out, noblock=1, fragment="SWIG_SciDouble_FromIntArrayAndSize") int[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromIntArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;

  %apply SWIGTYPE[] { int[] };
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDoubleOrInt32_AsIntArrayAndSize") int[] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  int *pTempData = NULL;
  if (SWIG_SciDoubleOrInt32_AsIntArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
/*@SWIG@*/
;

// Unsigned int
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,56,%scilab_array_typemaps@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,27,%scilab_asarrayandsize_withcopy@*/
%typemap(varin, fragment="SWIG_SciDoubleOrUint32_AsUnsignedIntArrayAndSize") unsigned int[ANY] {
  int iRows = 0;
  int iCols = 0;
  unsigned int *pTempData = NULL;
  if (SWIG_SciDoubleOrUint32_AsUnsignedIntArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  if (iRows*iCols <= $1_dim0) {
    size_t i;
    for (i = 0; i < $1_dim0; i++) {
      $1[i] = ($*1_ltype) pTempData[i];
    }
  }
  else {
    char errmsg[100];
    sprintf(errmsg, "Size of input data (%d) is too big (maximum is %d)",
      iRows*iCols, $1_dim0);
    SWIG_exception_fail(SWIG_OverflowError, errmsg);
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDoubleOrUint32_AsUnsignedIntArrayAndSize") unsigned int[ANY] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  unsigned int *pTempData = NULL;
  if (SWIG_SciDoubleOrUint32_AsUnsignedIntArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(varout, noblock=1, fragment="SWIG_SciDouble_FromUnsignedIntArrayAndSize") unsigned int[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromUnsignedIntArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(out, noblock=1, fragment="SWIG_SciDouble_FromUnsignedIntArrayAndSize") unsigned int[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromUnsignedIntArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;

  %apply SWIGTYPE[] { unsigned int[] };
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDoubleOrUint32_AsUnsignedIntArrayAndSize") unsigned int[] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  unsigned int *pTempData = NULL;
  if (SWIG_SciDoubleOrUint32_AsUnsignedIntArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
/*@SWIG@*/
;

// Long
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,56,%scilab_array_typemaps@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,27,%scilab_asarrayandsize_withcopy@*/
%typemap(varin, fragment="SWIG_SciDoubleOrInt32_AsIntArrayAndSize") long[ANY] {
  int iRows = 0;
  int iCols = 0;
  int *pTempData = NULL;
  if (SWIG_SciDoubleOrInt32_AsIntArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  if (iRows*iCols <= $1_dim0) {
    size_t i;
    for (i = 0; i < $1_dim0; i++) {
      $1[i] = ($*1_ltype) pTempData[i];
    }
  }
  else {
    char errmsg[100];
    sprintf(errmsg, "Size of input data (%d) is too big (maximum is %d)",
      iRows*iCols, $1_dim0);
    SWIG_exception_fail(SWIG_OverflowError, errmsg);
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDoubleOrInt32_AsIntArrayAndSize") long[ANY] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  int *pTempData = NULL;
  if (SWIG_SciDoubleOrInt32_AsIntArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(varout, noblock=1, fragment="SWIG_SciDouble_FromLongArrayAndSize") long[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromLongArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(out, noblock=1, fragment="SWIG_SciDouble_FromLongArrayAndSize") long[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromLongArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;

  %apply SWIGTYPE[] { long[] };
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDoubleOrInt32_AsIntArrayAndSize") long[] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  int *pTempData = NULL;
  if (SWIG_SciDoubleOrInt32_AsIntArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
/*@SWIG@*/
;

// Unsigned long
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,56,%scilab_array_typemaps@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,27,%scilab_asarrayandsize_withcopy@*/
%typemap(varin, fragment="SWIG_SciDoubleOrUint32_AsUnsignedIntArrayAndSize") unsigned long[ANY] {
  int iRows = 0;
  int iCols = 0;
  unsigned int *pTempData = NULL;
  if (SWIG_SciDoubleOrUint32_AsUnsignedIntArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  if (iRows*iCols <= $1_dim0) {
    size_t i;
    for (i = 0; i < $1_dim0; i++) {
      $1[i] = ($*1_ltype) pTempData[i];
    }
  }
  else {
    char errmsg[100];
    sprintf(errmsg, "Size of input data (%d) is too big (maximum is %d)",
      iRows*iCols, $1_dim0);
    SWIG_exception_fail(SWIG_OverflowError, errmsg);
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDoubleOrUint32_AsUnsignedIntArrayAndSize") unsigned long[ANY] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  unsigned int *pTempData = NULL;
  if (SWIG_SciDoubleOrUint32_AsUnsignedIntArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(varout, noblock=1, fragment="SWIG_SciDouble_FromUnsignedLongArrayAndSize") unsigned long[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromUnsignedLongArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(out, noblock=1, fragment="SWIG_SciDouble_FromUnsignedLongArrayAndSize") unsigned long[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromUnsignedLongArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;

  %apply SWIGTYPE[] { unsigned long[] };
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDoubleOrUint32_AsUnsignedIntArrayAndSize") unsigned long[] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  unsigned int *pTempData = NULL;
  if (SWIG_SciDoubleOrUint32_AsUnsignedIntArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
/*@SWIG@*/
;

// Float
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,56,%scilab_array_typemaps@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,27,%scilab_asarrayandsize_withcopy@*/
%typemap(varin, fragment="SWIG_SciDouble_AsFloatArrayAndSize") float[ANY] {
  int iRows = 0;
  int iCols = 0;
  float *pTempData = NULL;
  if (SWIG_SciDouble_AsFloatArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  if (iRows*iCols <= $1_dim0) {
    size_t i;
    for (i = 0; i < $1_dim0; i++) {
      $1[i] = ($*1_ltype) pTempData[i];
    }
  }
  else {
    char errmsg[100];
    sprintf(errmsg, "Size of input data (%d) is too big (maximum is %d)",
      iRows*iCols, $1_dim0);
    SWIG_exception_fail(SWIG_OverflowError, errmsg);
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDouble_AsFloatArrayAndSize") float[ANY] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  float *pTempData = NULL;
  if (SWIG_SciDouble_AsFloatArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(varout, noblock=1, fragment="SWIG_SciDouble_FromFloatArrayAndSize") float[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromFloatArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(out, noblock=1, fragment="SWIG_SciDouble_FromFloatArrayAndSize") float[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciDouble_FromFloatArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;

  %apply SWIGTYPE[] { float[] };
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciDouble_AsFloatArrayAndSize") float[] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  float *pTempData = NULL;
  if (SWIG_SciDouble_AsFloatArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
/*@SWIG@*/
;

// Bool
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,56,%scilab_array_typemaps@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,27,%scilab_asarrayandsize_withcopy@*/
%typemap(varin, fragment="SWIG_SciBoolean_AsIntArrayAndSize") bool[ANY] {
  int iRows = 0;
  int iCols = 0;
  int *pTempData = NULL;
  if (SWIG_SciBoolean_AsIntArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  if (iRows*iCols <= $1_dim0) {
    size_t i;
    for (i = 0; i < $1_dim0; i++) {
      $1[i] = ($*1_ltype) pTempData[i];
    }
  }
  else {
    char errmsg[100];
    sprintf(errmsg, "Size of input data (%d) is too big (maximum is %d)",
      iRows*iCols, $1_dim0);
    SWIG_exception_fail(SWIG_OverflowError, errmsg);
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciBoolean_AsIntArrayAndSize") bool[ANY] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  int *pTempData = NULL;
  if (SWIG_SciBoolean_AsIntArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(varout, noblock=1, fragment="SWIG_SciBoolean_FromBoolArrayAndSize") bool[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciBoolean_FromBoolArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(out, noblock=1, fragment="SWIG_SciBoolean_FromBoolArrayAndSize") bool[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciBoolean_FromBoolArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;

  %apply SWIGTYPE[] { bool[] };
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciBoolean_AsIntArrayAndSize") bool[] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  int *pTempData = NULL;
  if (SWIG_SciBoolean_AsIntArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
/*@SWIG@*/
;

// Char *
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,56,%scilab_array_typemaps@*/
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,27,%scilab_asarrayandsize_withcopy@*/
%typemap(varin, fragment="SWIG_SciString_AsCharPtrArrayAndSize") char *[ANY] {
  int iRows = 0;
  int iCols = 0;
  char * *pTempData = NULL;
  if (SWIG_SciString_AsCharPtrArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  if (iRows*iCols <= $1_dim0) {
    size_t i;
    for (i = 0; i < $1_dim0; i++) {
      $1[i] = ($*1_ltype) pTempData[i];
    }
  }
  else {
    char errmsg[100];
    sprintf(errmsg, "Size of input data (%d) is too big (maximum is %d)",
      iRows*iCols, $1_dim0);
    SWIG_exception_fail(SWIG_OverflowError, errmsg);
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciString_AsCharPtrArrayAndSize") char *[ANY] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  char * *pTempData = NULL;
  if (SWIG_SciString_AsCharPtrArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(varout, noblock=1, fragment="SWIG_SciString_FromCharPtrArrayAndSize") char *[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciString_FromCharPtrArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,50,%scilab_fromarrayandsize@*/
%typemap(out, noblock=1, fragment="SWIG_SciString_FromCharPtrArrayAndSize") char *[ANY] {
  if (!SWIG_IsOK(SWIG_Scilab_SetOutput(pvApiCtx, SWIG_SciString_FromCharPtrArrayAndSize(pvApiCtx, $result, 1, $1_dim0, $1)))) return SWIG_ERROR;
}
/*@SWIG@*/;

  %apply SWIGTYPE[] { char *[] };
  /*@SWIG:/usr/local/share/swig/4.0.0/scilab/sciarray.swg,11,%scilab_asarray_withallocatecopy@*/
%typemap(in, fragment="SWIG_SciString_AsCharPtrArrayAndSize") char *[] {
  size_t i = 0;
  int iRows = 0;
  int iCols = 0;
  char * *pTempData = NULL;
  if (SWIG_SciString_AsCharPtrArrayAndSize(pvApiCtx, $input, &iRows, &iCols, &pTempData, fname)) {
    return SWIG_ERROR;
  }
  $1 = ($1_ltype)MALLOC(sizeof($*1_ltype) * iRows * iCols);
  for (i = 0; i < iRows * iCols; i++) {
    $1[i] = ($*1_ltype) pTempData[i];
  }
}
/*@SWIG@*/;
/*@SWIG@*/
;

%endoffile


/* ---------------------------------------------------------------------------*/
/* Enum typemaps                                                              */
/* ---------------------------------------------------------------------------*/

%typemap(in, noblock=1, fragment="SWIG_" "AsVal" "_" {Enum}) enum SWIGTYPE (int val) {
  if (SWIG_AsVal_Enum ($input, &val) != SWIG_OK) {
    return SWIG_ERROR;
  }
  $1 = ($ltype)(val);
}

%typemap(out, fragment="SWIG_" "From" "_" {Enum}) enum SWIGTYPE {
  if (SWIG_From_Enum  ($1) != SWIG_OK) {
    return SWIG_ERROR;
  }
}

/* ---------------------------------------------------------------------------*/
/* Typecheck typemaps                                                         */
/* ---------------------------------------------------------------------------*/













%fragment("SWIG_Check_SciDoubleOrInt", "header") {
SWIGINTERN int
SWIG_Check_SciDoubleOrInt(void *pvApiCtx, SwigSciObject iVar, int iIntegerType) {
  int *piAddrVar = NULL;
  int ret = 0;
  SciErr sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return 0;
  }
  ret = isIntegerType(pvApiCtx, piAddrVar);
  if (ret == 1) {
    int iPrec = 0;
    sciErr = getMatrixOfIntegerPrecision(pvApiCtx, piAddrVar, &iPrec);
    if (sciErr.iErr) {
      printError(&sciErr, 0);
      return 0;
    }
    ret = (iPrec == iIntegerType) ? 1 : 0;
  }
  else {
    ret = isDoubleType(pvApiCtx, piAddrVar);
  }
  return ret;
}
}

/* Scilab equivalent for C integers can be sci_intXX or sci_matrix */













// Double (and Float) have priority over before Integer type.

// Primitive types
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,159,%scilab_typecheck_pointer@*/
 %typemap(typecheck, precedence=10)  SWIGTYPE * {
  $1 = SwigScilabCheckPtr(pvApiCtx, $input, $descriptor, SWIG_Scilab_GetFuncName());
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,159,%scilab_typecheck_pointer@*/
 %typemap(typecheck, precedence=0)  SWIGTYPE * {
  $1 = SwigScilabCheckPtr(pvApiCtx, $input, $descriptor, SWIG_Scilab_GetFuncName());
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,113,%scilab_typecheck_generic@*/
 %typemap(typecheck, precedence=15)  bool {
  int *piAddrVar = NULL;
  SciErr sciErr = getVarAddressFromPosition(pvApiCtx, $input, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }
  $1 = isBooleanType(pvApiCtx, piAddrVar);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,113,%scilab_typecheck_generic@*/
 %typemap(typecheck, precedence=16)  double {
  int *piAddrVar = NULL;
  SciErr sciErr = getVarAddressFromPosition(pvApiCtx, $input, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }
  $1 = isDoubleType(pvApiCtx, piAddrVar);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,113,%scilab_typecheck_generic@*/
 %typemap(typecheck, precedence=17)  float {
  int *piAddrVar = NULL;
  SciErr sciErr = getVarAddressFromPosition(pvApiCtx, $input, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }
  $1 = isDoubleType(pvApiCtx, piAddrVar);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,153,%scilab_typecheck_integer@*/
 %typemap(typecheck, precedence=25,fragment="SWIG_Check_SciDoubleOrInt")  signed char {
  $1 = SWIG_Check_SciDoubleOrInt(pvApiCtx, $input, SCI_INT8);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,153,%scilab_typecheck_integer@*/
 %typemap(typecheck, precedence=20,fragment="SWIG_Check_SciDoubleOrInt")  unsigned char {
  $1 = SWIG_Check_SciDoubleOrInt(pvApiCtx, $input, SCI_UINT8);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,153,%scilab_typecheck_integer@*/
 %typemap(typecheck, precedence=35,fragment="SWIG_Check_SciDoubleOrInt")  short {
  $1 = SWIG_Check_SciDoubleOrInt(pvApiCtx, $input, SCI_INT16);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,153,%scilab_typecheck_integer@*/
 %typemap(typecheck, precedence=30,fragment="SWIG_Check_SciDoubleOrInt")  unsigned short {
  $1 = SWIG_Check_SciDoubleOrInt(pvApiCtx, $input, SCI_UINT16);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,153,%scilab_typecheck_integer@*/
 %typemap(typecheck, precedence=45,fragment="SWIG_Check_SciDoubleOrInt")  int {
  $1 = SWIG_Check_SciDoubleOrInt(pvApiCtx, $input, SCI_INT32);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,153,%scilab_typecheck_integer@*/
 %typemap(typecheck, precedence=45,fragment="SWIG_Check_SciDoubleOrInt")  long {
  $1 = SWIG_Check_SciDoubleOrInt(pvApiCtx, $input, SCI_INT32);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,153,%scilab_typecheck_integer@*/
 %typemap(typecheck, precedence=40,fragment="SWIG_Check_SciDoubleOrInt")  unsigned int {
  $1 = SWIG_Check_SciDoubleOrInt(pvApiCtx, $input, SCI_UINT32);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,153,%scilab_typecheck_integer@*/
 %typemap(typecheck, precedence=40,fragment="SWIG_Check_SciDoubleOrInt")  unsigned long {
  $1 = SWIG_Check_SciDoubleOrInt(pvApiCtx, $input, SCI_UINT32);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,153,%scilab_typecheck_integer@*/
 %typemap(typecheck, precedence=45,fragment="SWIG_Check_SciDoubleOrInt")  enum SWIGTYPE {
  $1 = SWIG_Check_SciDoubleOrInt(pvApiCtx, $input, SCI_INT32);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,113,%scilab_typecheck_generic@*/
 %typemap(typecheck, precedence=130)  char {
  int *piAddrVar = NULL;
  SciErr sciErr = getVarAddressFromPosition(pvApiCtx, $input, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }
  $1 = isStringType(pvApiCtx, piAddrVar);
}
/*@SWIG@*/

// Arrays
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,113,%scilab_typecheck_generic@*/
 %typemap(typecheck, precedence=1015)  bool {
  int *piAddrVar = NULL;
  SciErr sciErr = getVarAddressFromPosition(pvApiCtx, $input, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }
  $1 = isBooleanType(pvApiCtx, piAddrVar);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,113,%scilab_typecheck_generic@*/
 %typemap(typecheck, precedence=1016)  double [ANY] {
  int *piAddrVar = NULL;
  SciErr sciErr = getVarAddressFromPosition(pvApiCtx, $input, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }
  $1 = isDoubleType(pvApiCtx, piAddrVar);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,113,%scilab_typecheck_generic@*/
 %typemap(typecheck, precedence=1017)  float [ANY] {
  int *piAddrVar = NULL;
  SciErr sciErr = getVarAddressFromPosition(pvApiCtx, $input, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }
  $1 = isDoubleType(pvApiCtx, piAddrVar);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,153,%scilab_typecheck_integer@*/
 %typemap(typecheck, precedence=1025,fragment="SWIG_Check_SciDoubleOrInt")  signed char [ANY] {
  $1 = SWIG_Check_SciDoubleOrInt(pvApiCtx, $input, SCI_INT8);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,153,%scilab_typecheck_integer@*/
 %typemap(typecheck, precedence=1026,fragment="SWIG_Check_SciDoubleOrInt")  unsigned char [ANY] {
  $1 = SWIG_Check_SciDoubleOrInt(pvApiCtx, $input, SCI_UINT8);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,153,%scilab_typecheck_integer@*/
 %typemap(typecheck, precedence=1035,fragment="SWIG_Check_SciDoubleOrInt")  short [ANY] {
  $1 = SWIG_Check_SciDoubleOrInt(pvApiCtx, $input, SCI_INT16);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,153,%scilab_typecheck_integer@*/
 %typemap(typecheck, precedence=1036,fragment="SWIG_Check_SciDoubleOrInt")  unsigned short [ANY] {
  $1 = SWIG_Check_SciDoubleOrInt(pvApiCtx, $input, SCI_UINT16);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,153,%scilab_typecheck_integer@*/
 %typemap(typecheck, precedence=1045,fragment="SWIG_Check_SciDoubleOrInt")  int [ANY] {
  $1 = SWIG_Check_SciDoubleOrInt(pvApiCtx, $input, SCI_INT32);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,153,%scilab_typecheck_integer@*/
 %typemap(typecheck, precedence=1045,fragment="SWIG_Check_SciDoubleOrInt")  long [ANY] {
  $1 = SWIG_Check_SciDoubleOrInt(pvApiCtx, $input, SCI_INT32);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,153,%scilab_typecheck_integer@*/
 %typemap(typecheck, precedence=1046,fragment="SWIG_Check_SciDoubleOrInt")  unsigned int [ANY] {
  $1 = SWIG_Check_SciDoubleOrInt(pvApiCtx, $input, SCI_UINT32);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,153,%scilab_typecheck_integer@*/
 %typemap(typecheck, precedence=1046,fragment="SWIG_Check_SciDoubleOrInt")  unsigned long [ANY] {
  $1 = SWIG_Check_SciDoubleOrInt(pvApiCtx, $input, SCI_UINT32);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,113,%scilab_typecheck_generic@*/
 %typemap(typecheck, precedence=1130)  char [ANY] {
  int *piAddrVar = NULL;
  SciErr sciErr = getVarAddressFromPosition(pvApiCtx, $input, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }
  $1 = isStringType(pvApiCtx, piAddrVar);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,113,%scilab_typecheck_generic@*/
 %typemap(typecheck, precedence=1140)  char *[ANY] {
  int *piAddrVar = NULL;
  SciErr sciErr = getVarAddressFromPosition(pvApiCtx, $input, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }
  $1 = isStringType(pvApiCtx, piAddrVar);
}
/*@SWIG@*/
/*@SWIG:/usr/local/share/swig/4.0.0/scilab/scitypemaps.swg,113,%scilab_typecheck_generic@*/
 %typemap(typecheck, precedence=1140)  char ** {
  int *piAddrVar = NULL;
  SciErr sciErr = getVarAddressFromPosition(pvApiCtx, $input, &piAddrVar);
  if (sciErr.iErr) {
    printError(&sciErr, 0);
    return SWIG_ERROR;
  }
  $1 = isStringType(pvApiCtx, piAddrVar);
}
/*@SWIG@*/


/* ---------------------------------------------------------------------------*/
/* %scilabconstcode() feature typemaps                                        */
/* ---------------------------------------------------------------------------*/

%typemap(scilabconstcode, fragment="SWIG_" "CreateScilabVariable" "_" {double}) double
%{
  if (SWIG_CreateScilabVariable_double(pvApiCtx, "$result", $value) != SWIG_OK)
    return SWIG_ERROR;
%}

%typemap(scilabconstcode, fragment="SWIG_" "CreateScilabVariable" "_" {int}) int
%{
  if (SWIG_CreateScilabVariable_int(pvApiCtx, "$result", $value) != SWIG_OK)
    return SWIG_ERROR;
%}

%typemap(scilabconstcode, fragment="SWIG_" "CreateScilabVariable" "_" {uint}) unsigned int
%{
  if (SWIG_CreateScilabVariable_uint(pvApiCtx, "$result", $value) != SWIG_OK)
    return SWIG_ERROR;
%}

%typemap(scilabconstcode, fragment="SWIG_" "CreateScilabVariable" "_" {int}) long
%{
  if (SWIG_CreateScilabVariable_int(pvApiCtx, "$result", $value) != SWIG_OK)
    return SWIG_ERROR;
%}

%typemap(scilabconstcode, fragment="SWIG_" "CreateScilabVariable" "_" {uint}) unsigned long
%{
  if (SWIG_CreateScilabVariable_uint(pvApiCtx, "$result", $value) != SWIG_OK)
    return SWIG_ERROR;
%}

%typemap(scilabconstcode, fragment="SWIG_" "CreateScilabVariable" "_" {char}) char
%{
  if (SWIG_CreateScilabVariable_char(pvApiCtx, "$result", $value) != SWIG_OK)
    return SWIG_ERROR;
%}

%typemap(scilabconstcode, fragment="SWIG_" "CreateScilabVariable" "_" {charptr}) char *
%{
  if (SWIG_CreateScilabVariable_charptr(pvApiCtx, "$result", $value) != SWIG_OK)
    return SWIG_ERROR;
%}

%typemap(scilabconstcode, fragment="SWIG_" "CreateScilabVariable" "_" {double}) enum SWIGTYPE
%{
  if (SWIG_CreateScilabVariable_double(pvApiCtx, "$result", $value) != SWIG_OK)
    return SWIG_ERROR;
%}


/* ---------------------------------------------------------------------------*/
/* Exception typmemaps                                                        */
/* ---------------------------------------------------------------------------*/

%includefile "/usr/local/share/swig/4.0.0/scilab/sciexception.swg" %beginfile
/*
 * Exception typemaps (throws)
 */

%includefile "/usr/local/share/swig/4.0.0/scilab/exception.i" %beginfile



%insert("runtime") {
  #define SWIG_exception(code, msg) SWIG_Scilab_Error(code, msg); 
}
%endoffile

%typemap(throws, noblock=1) int, unsigned int, signed int,
                            int&,unsigned int&, signed int&,
                            long, unsigned long, signed long,
                            short, unsigned short,signed short,
                            long long, unsigned long long,
                            unsigned char, signed char,
                            long&, unsigned long&, signed long&,
                            short&, unsigned short&, signed short&,
                            long long&, unsigned long long&,
                            unsigned char&, signed char&,
                            size_t, size_t&,
                            ptrdiff_t, ptrdiff_t& {
  char obj[20];
  sprintf(obj, "%d", (int)$1);
  SWIG_Scilab_Raise_Ex(obj, "$type", $descriptor);
}

%typemap(throws, noblock=1) enum SWIGTYPE {
  char obj[20];
  sprintf(obj, "%d", (int)$1);
  SWIG_Scilab_Raise_Ex(obj, "$type", $descriptor);
}

%typemap(throws, noblock=1) float, double,
                            float&, double& {
  char obj[20];
  sprintf(obj, "%5.3f", (double)$1);
  SWIG_Scilab_Raise_Ex(obj, "$type", $descriptor);
}

%typemap(throws, noblock=1) bool, bool& {
  SWIG_Scilab_Raise_Ex($1 ? "true" : "false", "$type", $descriptor);
}

%typemap(throws, noblock=1) char*, char[ANY] {
  SWIG_Scilab_Raise_Ex($1, "$type", $descriptor);
}

%typemap(throws, noblock=1) char, char& {
  char obj[1];
  sprintf(obj, "%c", (char)$1);
  SWIG_Scilab_Raise_Ex(obj, "$type", $descriptor);
}

%typemap(throws, noblock=1) SWIGTYPE,
                            SWIGTYPE*,
                            SWIGTYPE [ANY],
                            SWIGTYPE & {
  SWIG_Scilab_Raise_Ex((char*)NULL, "$type", $descriptor);
}

%typemap(throws, noblock=1) (...) {
  SWIG_exception(SWIG_RuntimeError, "unknown exception");
}
%endoffile
%endoffile

%endoffile
%includefile(maininput="icoFoam.i") "icoFoam.i" %beginfile
%module icoFoam

%inline %{
#include "Foam.h"
#include "fvCFD.H"
#include "pisoControl.H"
#include "parRun.H"

#include "Time.H"
#include "fvMesh.H"
#include "fvc.H"
#include "fvMatrices.H"
#include "fvm.H"
#include "linear.H"
#include "uniformDimensionedFields.H"
#include "calculatedFvPatchFields.H"
#include "extrapolatedCalculatedFvPatchFields.H"
#include "fixedValueFvPatchFields.H"
#include "zeroGradientFvPatchFields.H"
#include "fixedFluxPressureFvPatchScalarField.H"
#include "constrainHbyA.H"
#include "constrainPressure.H"
#include "adjustPhi.H"
#include "findRefCell.H"
#include "IOMRFZoneList.H"
#include "constants.H"

#include "OSspecific.H"
#include "argList.H"
#include "timeSelector.H"

%}

%importfile "fvCFD.H" %beginfile



// #include "parRun.H"

// #include "Time.H"
// #include "fvMesh.H"
// #include "fvc.H"
// #include "fvMatrices.H"
// #include "fvm.H"
// #include "linear.H"
// #include "uniformDimensionedFields.H"
// #include "calculatedFvPatchFields.H"
// #include "extrapolatedCalculatedFvPatchFields.H"
// #include "fixedValueFvPatchFields.H"
// #include "zeroGradientFvPatchFields.H"
// #include "fixedFluxPressureFvPatchScalarField.H"
// #include "constrainHbyA.H"
// #include "constrainPressure.H"
// #include "adjustPhi.H"
// #include "findRefCell.H"
// #include "IOMRFZoneList.H"
// #include "constants.H"

// #include "OSspecific.H"
// #include "argList.H"
// #include "timeSelector.H"

// #ifndef namespaceFoam
// #define namespaceFoam
//     using namespace Foam;
// #endif


%endoffile
%importfile "pisoControl.H" %beginfile
/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | Copyright (C) 2015-2016 OpenFOAM Foundation
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

Class
    Foam::pisoControl

Description
    Specialization of the pimpleControl class for PISO control.

\*---------------------------------------------------------------------------*/






//- Declare that pisoControl will be used



// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

namespace Foam
{

/*---------------------------------------------------------------------------*\
                        Class pisoControl Declaration
\*---------------------------------------------------------------------------*/

class pisoControl
:
    public pimpleControl
{
    // Private member functions

        //- Disallow default bitwise copy construct
        pisoControl(const pisoControl&);

        //- Disallow default bitwise assignment
        void operator=(const pisoControl&);


public:

    // Static Data Members

        //- Run-time type information
        // TypeName("pisoControl");


    // Constructors

        //- Construct from mesh and the name of control sub-dictionary
        pisoControl(fvMesh& mesh, const word& dictName="PISO");


    //- Destructor
    virtual ~pisoControl();


    // Member Functions

        // Solution control

            //- Return true if in the final inner (PISO) iteration
            inline bool finalInnerIter() const;
};


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //



// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

} // End namespace Foam

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //



// ************************************************************************* //
%endoffile
%inline %{
extern int icoFoam(int argc, char *argv[]);

%}
%endoffile
